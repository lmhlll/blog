<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
        <title>Hacker&#39;s guide to Neural Networks - Li Minghui&#39;s Blog</title><meta name="Description" content="Thinking ahead"><meta property="og:title" content="Hacker&#39;s guide to Neural Networks" />
<meta property="og:description" content="Hi there, I&rsquo;m a CS PhD student at Stanford. I&rsquo;ve worked on Deep Learning for a few years as part of my research and among several of my related pet projects is ConvNetJS - a Javascript library for training Neural Networks. Javascript allows one to nicely visualize what&rsquo;s going on and to play around with the various hyperparameter settings, but I still regularly hear from people who ask for a more thorough treatment of the topic." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://example.org/nntutorial/" /><meta property="og:image" content="http://example.org/lmh.jpg"/><meta property="article:section" content="posts" />



<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="http://example.org/lmh.jpg"/>

<meta name="twitter:title" content="Hacker&#39;s guide to Neural Networks"/>
<meta name="twitter:description" content="Hi there, I&rsquo;m a CS PhD student at Stanford. I&rsquo;ve worked on Deep Learning for a few years as part of my research and among several of my related pet projects is ConvNetJS - a Javascript library for training Neural Networks. Javascript allows one to nicely visualize what&rsquo;s going on and to play around with the various hyperparameter settings, but I still regularly hear from people who ask for a more thorough treatment of the topic."/>
<meta name="application-name" content="lmh">
<meta name="apple-mobile-web-app-title" content="lmh"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="http://example.org/nntutorial/" /><link rel="next" href="http://example.org/test_post/" /><link rel="stylesheet" href="/lib/normalize/normalize.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"><link rel="stylesheet" href="/lib/animate/animate.min.css"><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "Hacker's guide to Neural Networks",
        "inLanguage": "en",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "http:\/\/example.org\/nntutorial\/"
        },"genre": "posts","wordcount":  13952 ,
        "url": "http:\/\/example.org\/nntutorial\/","publisher": {
            "@type": "Organization",
            "name": ""},"author": {
                "@type": "Person",
                "name": "Li Minghui"
            },"description": ""
    }
    </script></head>
    <body header-desktop="fixed" header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="Li Minghui&#39;s Blog"><img
        class="lazyload logo"
        src="/svg/loading.min.svg"
        data-src="touxiang.JPG"
        data-srcset="touxiang.JPG, touxiang.JPG 1.5x, touxiang.JPG 2x"
        data-sizes="auto"
        alt="touxiang.JPG"
        title="touxiang.JPG" />Li Minghui&#39;s Blog</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/" title="lmh"> Posts </a><a class="menu-item" href="/tags/"> Tags </a><a class="menu-item" href="/categories/"> Categories </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="Search titles or contents..." id="search-input-desktop">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="Search">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="Clear">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </span><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                    <i class="fas fa-adjust fa-fw"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="Li Minghui&#39;s Blog"><img
        class="lazyload logo"
        src="/svg/loading.min.svg"
        data-src="touxiang.JPG"
        data-srcset="touxiang.JPG, touxiang.JPG 1.5x, touxiang.JPG 2x"
        data-sizes="auto"
        alt="touxiang.JPG"
        title="touxiang.JPG" />Li Minghui&#39;s Blog</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="Search titles or contents..." id="search-input-mobile">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="Search">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="Clear">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </div>
                    <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
                        Cancel
                    </a>
                </div><a class="menu-item" href="/posts/" title="lmh">Posts</a><a class="menu-item" href="/tags/" title="">Tags</a><a class="menu-item" href="/categories/" title="">Categories</a><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                <i class="fas fa-adjust fa-fw"></i>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">Contents</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animated flipInX">Hacker&#39;s guide to Neural Networks</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="/" title="Author" rel=" author" class="author"><i class="fas fa-user-circle fa-fw"></i>Li Minghui</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="0001-01-01">0001-01-01</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;13952 words&nbsp;
                <i class="far fa-clock fa-fw"></i>&nbsp;66 minutes&nbsp;</div>
        </div><div class="details toc" id="toc-static"  kept="true">
                <div class="details-summary toc-title">
                    <span>Contents</span>
                    <span><i class="details-icon fas fa-angle-right"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#chapter-1-real-valued-circuits">Chapter 1: Real-valued Circuits</a>
      <ul>
        <li><a href="#base-case-single-gate-in-the-circuit">Base Case: Single Gate in the Circuit</a>
          <ul>
            <li><a href="#the-goal">The Goal</a></li>
            <li><a href="#strategy-1-random-local-search">Strategy #1: Random Local Search</a></li>
            <li><a href="#stategy-2-numerical-gradient">Stategy #2: Numerical Gradient</a></li>
            <li><a href="#strategy-3-analytic-gradient">Strategy #3: Analytic Gradient</a></li>
          </ul>
        </li>
        <li><a href="#recursive-case-circuits-with-multiple-gates">Recursive Case: Circuits with Multiple Gates</a>
          <ul>
            <li><a href="#backpropagation">Backpropagation</a></li>
            <li><a href="#patterns-in-the-backward-flow">Patterns in the &ldquo;backward&rdquo; flow</a></li>
          </ul>
        </li>
        <li><a href="#example-single-neuron">Example: Single Neuron</a></li>
        <li><a href="#becoming-a-backprop-ninja">Becoming a Backprop Ninja</a></li>
      </ul>
    </li>
    <li><a href="#chapter-2-machine-learning">Chapter 2: Machine Learning</a>
      <ul>
        <li><a href="#binary-classification">Binary Classification</a>
          <ul>
            <li><a href="#training-protocol">Training protocol</a></li>
            <li><a href="#learning-a-support-vector-machine">Learning a Support Vector Machine</a></li>
            <li><a href="#generalizing-the-svm-into-a-neural-network">Generalizing the SVM into a Neural Network</a></li>
          </ul>
        </li>
        <li><a href="#a-more-conventional-approach-loss-functions">A more Conventional Approach: Loss Functions</a>
          <ul>
            <li><a href="#example-2-d-support-vector-machine">Example: 2-D Support Vector Machine</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#chapter-3-backprop-in-practice">Chapter 3: Backprop in Practice</a>
      <ul>
        <li><a href="#building-up-a-library">Building up a library</a></li>
        <li><a href="#example-practical-neural-network-classifier">Example: Practical Neural Network Classifier</a></li>
        <li><a href="#example-regression">Example: Regression</a></li>
        <li><a href="#example-structured-prediction">Example: Structured Prediction</a></li>
        <li><a href="#vectorized-implementations">Vectorized Implementations</a></li>
        <li><a href="#backprop-in-practice-tipstricks">Backprop in practice: Tips/Tricks</a></li>
      </ul>
    </li>
    <li><a href="#chapter-4-networks-in-the-wild">Chapter 4: Networks in the Wild</a>
      <ul>
        <li><a href="#case-study-convolutional-neural-networks-for-images">Case Study: Convolutional Neural Networks for images</a></li>
        <li><a href="#case-study-recurrent-neural-networks-for-speech-and-text">Case Study: Recurrent Neural Networks for Speech and Text</a></li>
        <li><a href="#case-study-word2vec">Case Study: Word2Vec</a></li>
        <li><a href="#case-study-t-sne">Case Study: t-SNE</a></li>
      </ul>
    </li>
    <li><a href="#acknowledgements">Acknowledgements</a></li>
    <li><a href="#comments">Comments</a></li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><p>Hi there, I&rsquo;m a <a href="http://cs.stanford.edu/people/karpathy/" target="_blank" rel="noopener noreffer">CS PhD student at Stanford</a>. I&rsquo;ve worked on Deep Learning for a few years as part of my research and among several of my related pet projects is <a href="http://convnetjs.com" target="_blank" rel="noopener noreffer">ConvNetJS</a> - a Javascript library for training Neural Networks. Javascript allows one to nicely visualize what&rsquo;s going on and to play around with the various hyperparameter settings, but I still regularly hear from people who ask for a more thorough treatment of the topic. This article (which I plan to slowly expand out to lengths of a few book chapters) is my humble attempt. It&rsquo;s on web instead of PDF because all books should be, and eventually it will hopefully include animations/demos etc.</p>
<p>My personal experience with Neural Networks is that everything became much clearer when I started ignoring full-page, dense derivations of backpropagation equations and just started writing code. Thus, this tutorial will contain <strong>very little math</strong> (I don&rsquo;t believe it is necessary and it can sometimes even obfuscate simple concepts). Since my background is in Computer Science and Physics, I will instead develop the topic from what I refer to as <strong>hackers&rsquo;s perspective</strong>. My exposition will center around code and physical intuitions instead of mathematical derivations. Basically, I will strive to present the algorithms in a way that I wish I had come across when I was starting out.</p>
<blockquote>
<p>&ldquo;&hellip;everything became much clearer when I started writing code.&rdquo;</p>
</blockquote>
<p>You might be eager to jump right in and learn about Neural Networks, backpropagation, how they can be applied to datasets in practice, etc. But before we get there, I&rsquo;d like us to first forget about all that. Let&rsquo;s take a step back and understand what is really going on at the core. Lets first talk about real-valued circuits.</p>
<p><em>Update note</em>: I suspended my work on this guide a while ago and redirected a lot of my energy to teaching CS231n (Convolutional Neural Networks) class at Stanford. The notes are on <a href="http://cs231n.github.io" target="_blank" rel="noopener noreffer">cs231.github.io</a> and the course slides can be found <a href="http://cs231n.stanford.edu/syllabus.html" target="_blank" rel="noopener noreffer">here</a>. These materials are highly related to material here, but more comprehensive and sometimes more polished.</p>
<h2 id="chapter-1-real-valued-circuits">Chapter 1: Real-valued Circuits</h2>
<p>In my opinion, the best way to think of Neural Networks is as real-valued circuits, where real values (instead of boolean values <code>{0,1}</code>) &ldquo;flow&rdquo; along edges and interact in gates. However, instead of gates such as <code>AND</code>, <code>OR</code>, <code>NOT</code>, etc, we have binary gates such as <code>*</code> (multiply), <code>+</code> (add), <code>max</code> or unary gates such as <code>exp</code>, etc. Unlike ordinary boolean circuits, however, we will eventually also have <strong>gradients</strong> flowing on the same edges of the circuit, but in the opposite direction. But we&rsquo;re getting ahead of ourselves. Let&rsquo;s focus and start out simple.</p>
<h3 id="base-case-single-gate-in-the-circuit">Base Case: Single Gate in the Circuit</h3>
<p>Lets first consider a single, simple circuit with one gate. Here&rsquo;s an example:</p>
<div class="svgdiv">
<svg width="400" height="150">
  <rect x="130" y="20" width="100" height="100" stroke="black" stroke-width="1" fill="white" />
  <line x1="90" y1="45" x2="130" y2="45" stroke="black" stroke-width="1" />
  <line x1="90" y1="95" x2="130" y2="95" stroke="black" stroke-width="1" />
  <text x="70" y="50" fill="black" text-anchor="middle" font-size="20px">x</text>
  <text x="70" y="100" fill="black" text-anchor="middle" font-size="20px">y</text>
<p><text x="180" y="90" fill="black" text-anchor="middle" font-size="40px">*</text>
<line x1="230" y1="70" x2="280" y2="70" stroke="black" stroke-width="1" />
</svg></p>
</div>
<p>The circuit takes two real-valued inputs <code>x</code> and <code>y</code> and computes <code>x * y</code> with the <code>*</code> gate. Javascript version of this would very simply look something like this:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">forwardMultiplyGate</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nx">forwardMultiplyGate</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span> <span class="c1">// returns -6. Exciting.
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>And in math form we can think of this gate as implementing the real-valued function:</p>
<p>$$
f(x,y) = x y
$$</p>
<p>As with this example, all of our gates will take one or two inputs and produce a <strong>single</strong> output value.</p>
<h4 id="the-goal">The Goal</h4>
<p>The problem we are interested in studying looks as follows:</p>
<ol>
<li>We provide a given circuit some specific input values (e.g. <code>x = -2</code>, <code>y = 3</code>)</li>
<li>The circuit computes an output value (e.g. <code>-6</code>)</li>
<li>The core question then becomes: <em>How should one tweak the input slightly to increase the output?</em></li>
</ol>
<p>In this case, in what direction should we change <code>x,y</code> to get a number larger than <code>-6</code>? Note that, for example, <code>x = -1.99</code> and <code>y = 2.99</code> gives <code>x * y = -5.95</code>, which is higher than <code>-6.0</code>. Don&rsquo;t get confused by this: <code>-5.95</code> is better (higher) than <code>-6.0</code>. It&rsquo;s an improvement of <code>0.05</code>, even though the <em>magnitude</em> of <code>-5.95</code> (the distance from zero) happens to be lower.</p>
<h4 id="strategy-1-random-local-search">Strategy #1: Random Local Search</h4>
<p>Okay. So wait, we have a circuit, we have some inputs and we just want to tweak them slightly to increase the output value? Why is this hard? We can easily &ldquo;forward&rdquo; the circuit to compute the output for any given <code>x</code> and <code>y</code>. So isn&rsquo;t this trivial? Why don&rsquo;t we tweak <code>x</code> and <code>y</code> randomly and keep track of the tweak that works best:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="c1">// circuit with single gate for now
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">forwardMultiplyGate</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">y</span><span class="p">;</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="c1">// some input values
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// try changing x,y randomly small amounts and keep track of what works best
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">tweak_amount</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">best_out</span> <span class="o">=</span> <span class="o">-</span><span class="kc">Infinity</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">best_x</span> <span class="o">=</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">best_y</span> <span class="o">=</span> <span class="nx">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">k</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="nx">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">var</span> <span class="nx">x_try</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">tweak_amount</span> <span class="o">*</span> <span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">()</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// tweak x a bit
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kd">var</span> <span class="nx">y_try</span> <span class="o">=</span> <span class="nx">y</span> <span class="o">+</span> <span class="nx">tweak_amount</span> <span class="o">*</span> <span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">()</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// tweak y a bit
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kd">var</span> <span class="nx">out</span> <span class="o">=</span> <span class="nx">forwardMultiplyGate</span><span class="p">(</span><span class="nx">x_try</span><span class="p">,</span> <span class="nx">y_try</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span><span class="nx">out</span> <span class="o">&gt;</span> <span class="nx">best_out</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// best improvement yet! Keep track of the x and y
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">best_out</span> <span class="o">=</span> <span class="nx">out</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="nx">best_x</span> <span class="o">=</span> <span class="nx">x_try</span><span class="p">,</span> <span class="nx">best_y</span> <span class="o">=</span> <span class="nx">y_try</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>When I run this, I get <code>best_x = -1.9928</code>, <code>best_y = 2.9901</code>, and <code>best_out = -5.9588</code>. Again, <code>-5.9588</code> is higher than <code>-6.0</code>. So, we&rsquo;re done, right? Not quite: This is a perfectly fine strategy for tiny problems with a few gates if you can afford the compute time, but it won&rsquo;t do if we want to eventually consider huge circuits with millions of inputs. It turns out that we can do much better.</p>
<h4 id="stategy-2-numerical-gradient">Stategy #2: Numerical Gradient</h4>
<p>Here&rsquo;s a better way. Remember again that in our setup we are given a circuit (e.g. our circuit with a single <code>*</code> gate) and some particular input (e.g. <code>x = -2, y = 3</code>). The gate computes the output (<code>-6</code>) and now we&rsquo;d like to tweak <code>x</code> and <code>y</code> to make the output higher.</p>
<p>A nice intuition for what we&rsquo;re about to do is as follows: Imagine taking the output value that comes out from the circuit and tugging on it in the positive direction. This positive tension will in turn translate through the gate and induce forces on the inputs <code>x</code> and <code>y</code>. Forces that tell us how <code>x</code> and <code>y</code> should change to increase the output value.</p>
<p>What might those forces look like in our specific example? Thinking through it, we can intuit that the force on <code>x</code> should also be positive, because making <code>x</code> slightly larger improves the circuit&rsquo;s output. For example, increasing <code>x</code> from <code>x = -2</code> to <code>x = -1</code> would give us output <code>-3</code> - much larger than <code>-6</code>. On the other hand, we&rsquo;d expect a negative force induced on <code>y</code> that pushes it to become lower (since a lower <code>y</code>, such as <code>y = 2</code>, down from the original <code>y = 3</code> would make output higher: <code>2 x -2 = -4</code>, again, larger than <code>-6</code>). That&rsquo;s the intuition to keep in mind, anyway. As we go through this, it will turn out that forces I&rsquo;m describing will in fact turn out to be the <strong>derivative</strong> of the output value with respect to its inputs (<code>x</code> and <code>y</code>). You may have heard this term before.</p>
<blockquote>
<p>The derivative can be thought of as a force on each input as we pull on the output to become higher.</p>
</blockquote>
<p>So how do we exactly evaluate this force (derivative)? It turns out that there is a very simple procedure for this. We will work backwards: Instead of pulling on the circuit&rsquo;s output, we&rsquo;ll iterate over every input one by one, increase it very slightly and look at what happens to the output value. The amount the output changes in response is the derivative. Enough intuitions for now. Lets look at the mathematical definition. We can write down the derivative for our function with respect to the inputs. For example, the derivative with respect to <code>x</code> can be computed as:</p>
<div>
$$
\frac{\partial f(x,y)}{\partial x} = \frac{f(x+h,y) - f(x,y)}{h}
$$
</div>
<p>Where \( h \) is small - it&rsquo;s the tweak amount. Also, if you&rsquo;re not very familiar with calculus it is important to note that in the left-hand side of the equation above, the horizontal line does <em>not</em> indicate division. The entire symbol \( \frac{\partial f(x,y)}{\partial x} \) is a single thing: the derivative of the function \( f(x,y) \) with respect to \( x \). The horizontal line on the right <em>is</em> division. I know it&rsquo;s confusing but it&rsquo;s standard notation. Anyway, I hope it doesn&rsquo;t look too scary because it isn&rsquo;t: The circuit was giving some initial output \( f(x,y) \), and then we changed one of the inputs by a tiny amount \(h \) and read the new output \( f(x+h, y) \). Subtracting those two quantities tells us the change, and the division by \(h \) just normalizes this change by the (arbitrary) tweak amount we used. In other words it&rsquo;s expressing exactly what I described above and translates directly to this code:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">out</span> <span class="o">=</span> <span class="nx">forwardMultiplyGate</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">);</span> <span class="c1">// -6
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">h</span> <span class="o">=</span> <span class="mf">0.0001</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// compute derivative with respect to x
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">xph</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">h</span><span class="p">;</span> <span class="c1">// -1.9999
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">out2</span> <span class="o">=</span> <span class="nx">forwardMultiplyGate</span><span class="p">(</span><span class="nx">xph</span><span class="p">,</span> <span class="nx">y</span><span class="p">);</span> <span class="c1">// -5.9997
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">x_derivative</span> <span class="o">=</span> <span class="p">(</span><span class="nx">out2</span> <span class="o">-</span> <span class="nx">out</span><span class="p">)</span> <span class="o">/</span> <span class="nx">h</span><span class="p">;</span> <span class="c1">// 3.0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// compute derivative with respect to y
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">yph</span> <span class="o">=</span> <span class="nx">y</span> <span class="o">+</span> <span class="nx">h</span><span class="p">;</span> <span class="c1">// 3.0001
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">out3</span> <span class="o">=</span> <span class="nx">forwardMultiplyGate</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">yph</span><span class="p">);</span> <span class="c1">// -6.0002
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">y_derivative</span> <span class="o">=</span> <span class="p">(</span><span class="nx">out3</span> <span class="o">-</span> <span class="nx">out</span><span class="p">)</span> <span class="o">/</span> <span class="nx">h</span><span class="p">;</span> <span class="c1">// -2.0
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>Lets walk through <code>x</code> for example. We turned the knob from <code>x</code> to <code>x + h</code> and the circuit responded by giving a higher value (note again that yes, <code>-5.9997</code> is <em>higher</em> than <code>-6</code>: <code>-5.9997 &gt; -6</code>). The division by <code>h</code> is there to normalize the circuit&rsquo;s response by the (arbitrary) value of <code>h</code> we chose to use here. Technically, you want the value of <code>h</code> to be infinitesimal (the precise mathematical definition of the gradient is defined as the limit of the expression as <code>h</code> goes to zero), but in practice <code>h=0.00001</code> or so works fine in most cases to get a good approximation. Now, we see that the derivative w.r.t. <code>x</code> is <code>+3</code>. I&rsquo;m making the positive sign explicit, because it indicates that the circuit is tugging on x to become higher. The actual value, <code>3</code> can be interpreted as the <em>force</em> of that tug.</p>
<blockquote>
<p>The derivative with respect to some input can be computed by tweaking that input by a small amount and observing the change on the output value.</p>
</blockquote>
<p>By the way, we usually  talk about the <em>derivative</em> with respect to a single input, or about a <strong>gradient</strong> with respect to all the inputs. The gradient is just made up of the derivatives of all the inputs concatenated in a vector (i.e. a list). Crucially, notice that if we let the inputs respond to the tug by following the gradient a tiny amount (i.e. we just add the derivative on top of every input), we can see that the value increases, as expected:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">step_size</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">out</span> <span class="o">=</span> <span class="nx">forwardMultiplyGate</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">);</span> <span class="c1">// before: -6
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">x</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">step_size</span> <span class="o">*</span> <span class="nx">x_derivative</span><span class="p">;</span> <span class="c1">// x becomes -1.97
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">y</span> <span class="o">=</span> <span class="nx">y</span> <span class="o">+</span> <span class="nx">step_size</span> <span class="o">*</span> <span class="nx">y_derivative</span><span class="p">;</span> <span class="c1">// y becomes 2.98
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">out_new</span> <span class="o">=</span> <span class="nx">forwardMultiplyGate</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">);</span> <span class="c1">// -5.87! exciting.
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>As expected, we changed the inputs by the gradient and the circuit now gives a slightly higher value (<code>-5.87 &gt; -6.0</code>). That was much simpler than trying random changes to <code>x</code> and <code>y</code>, right? A fact to appreciate here is that if you take calculus you can prove that the gradient is, in fact, the direction of the steepest increase of the function. There is no need to monkey around trying out random pertubations as done in Strategy #1. Evaluating the gradient requires just three evaluations of the forward pass of our circuit instead of hundreds, and gives the best tug you can hope for (locally) if you are interested in increasing the value of the output.</p>
<p><strong>Bigger step is not always better.</strong> Let me clarify on this point a bit. It is important to note that in this very simple example, using a bigger <code>step_size</code> than 0.01  will always work better. For example, <code>step_size = 1.0</code> gives output <code>-1</code> (higer, better!), and indeed infinite step size would give infinitely good results. The crucial thing to realize is that once our circuits get much more complex (e.g. entire neural networks), the function from inputs to the output value will be more chaotic and wiggly. The gradient guarantees that if you have a very small (indeed, infinitesimally small) step size, then you will definitely get a higher number when you follow its direction, and for that infinitesimally small step size there is no other direction that would have worked better. But if you use a bigger step size (e.g. <code>step_size = 0.01</code>) all bets are off. The reason we can get away with a larger step size than infinitesimally small is that our functions are usually relatively smooth. But really, we&rsquo;re crossing our fingers and hoping for the best.</p>
<p><strong>Hill-climbing analogy.</strong> One analogy I&rsquo;ve heard before is that the output value of our circut is like the height of a hill, and we are blindfolded and trying to climb upwards. We can sense the steepness of the hill at our feet (the gradient), so when we shuffle our feet a bit we will go upwards. But if we took a big, overconfident step, we could have stepped right into a hole.</p>
<p>Great, I hope I&rsquo;ve convinced you that the numerical gradient is indeed a very useful thing to evaluate, and that it is cheap. But. It turns out that we can do <em>even</em> better.</p>
<h4 id="strategy-3-analytic-gradient">Strategy #3: Analytic Gradient</h4>
<p>In the previous section we evaluated the gradient by probing the circuit&rsquo;s output value, independently for every input. This procedure gives you what we call a <strong>numerical gradient</strong>. This approach, however, is <em>still</em> expensive because we need to compute the circuit&rsquo;s output as we tweak every input value independently a small amount. So the complexity of evaluating the gradient is linear in number of inputs. But in practice we will have hundreds, thousands or (for neural networks) even tens to hundreds of millions of inputs, and the circuits aren&rsquo;t just one multiply gate but huge expressions that can be expensive to compute. We need something better.</p>
<p>Luckily, there is an easier and <em>much</em> faster way to compute the gradient: we can use calculus to derive a direct expression for it that will be as simple to evaluate as the circuit&rsquo;s output value. We call this an <strong>analytic gradient</strong> and there will be no need for tweaking anything. You may have seen other people who teach Neural Networks derive the gradient in huge and, frankly, scary and confusing mathematical equations (if you&rsquo;re not well-versed in maths). But it&rsquo;s unnecessary. I&rsquo;ve written plenty of Neural Nets code and I rarely have to do mathematical derivation longer than two lines, and 95% of the time it can be done without writing anything at all. That is because we will only ever derive the gradient for very small and simple expressions (think of it as the <strong>base case</strong>) and then I will show you how we can compose these very simply with <strong>chain rule</strong> to evaluate the full gradient (think inductive/recursive case).</p>
<blockquote>
<p>The analytic derivative requires no tweaking of the inputs. It can be derived using mathematics (calculus).</p>
</blockquote>
<p>If you remember your product rules, power rules, quotient rules, etc. (see e.g. <a href="http://www.mathsisfun.com/calculus/derivatives-rules.html" target="_blank" rel="noopener noreffer">derivative rules</a> or <a href="http://en.wikipedia.org/wiki/Differentiation_rules" target="_blank" rel="noopener noreffer">wiki page</a>), it&rsquo;s very easy to write down the derivitative with respect to both <code>x</code> and <code>y</code> for a small expression such as <code>x * y</code>. But suppose you don&rsquo;t remember your calculus rules. We can go back to the definition. For example, here&rsquo;s the expression for the derivative w.r.t <code>x</code>:</p>
<div>
$$
\frac{\partial f(x,y)}{\partial x} = \frac{f(x+h,y) - f(x,y)}{h}
$$
</div>
<p>(Technically I&rsquo;m not writing the limit as <code>h</code> goes to zero, forgive me math people). Okay and lets plug in our function ( \( f(x,y) = x y \) ) into the expression. Ready for the hardest piece of math of this entire article? Here we go:</p>
<div>
$$
\frac{\partial f(x,y)}{\partial x} = \frac{f(x+h,y) - f(x,y)}{h}
= \frac{(x+h)y - xy}{h}
= \frac{xy + hy - xy}{h}
= \frac{hy}{h}
= y
$$
</div>
<p>That&rsquo;s interesting. The derivative with respect to <code>x</code> is just equal to <code>y</code>. Did you notice the coincidence in the previous section? We tweaked <code>x</code> to <code>x+h</code> and calculated <code>x_derivative = 3.0</code>, which exactly happens to be the value of <code>y</code> in that example. It turns out that wasn&rsquo;t a coincidence at all because that&rsquo;s just what the analytic gradient tells us the <code>x</code> derivative should be for <code>f(x,y) = x * y</code>. The derivative with respect to <code>y</code>, by the way, turns out to be <code>x</code>, unsurprisingly by symmetry. So there is no need for any tweaking! We invoked powerful mathematics and can now transform our derivative calculation into the following code:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">out</span> <span class="o">=</span> <span class="nx">forwardMultiplyGate</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">);</span> <span class="c1">// before: -6
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">x_gradient</span> <span class="o">=</span> <span class="nx">y</span><span class="p">;</span> <span class="c1">// by our complex mathematical derivation above
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">y_gradient</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">step_size</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">x</span> <span class="o">+=</span> <span class="nx">step_size</span> <span class="o">*</span> <span class="nx">x_gradient</span><span class="p">;</span> <span class="c1">// -2.03
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">y</span> <span class="o">+=</span> <span class="nx">step_size</span> <span class="o">*</span> <span class="nx">y_gradient</span><span class="p">;</span> <span class="c1">// 2.98
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">out_new</span> <span class="o">=</span> <span class="nx">forwardMultiplyGate</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">);</span> <span class="c1">// -5.87. Higher output! Nice.
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>To compute the gradient we went from forwarding the circuit hundreds of times (Strategy #1) to forwarding it only on order of number of times twice the number of inputs (Strategy #2), to forwarding it a single time! And it gets EVEN better, since the more expensive strategies (#1 and #2) only give an approximation of the gradient, while #3 (the fastest one by far) gives you the <em>exact</em> gradient. No approximations. The only downside is that you should be comfortable with some calculus 101.</p>
<p>Lets recap what we have learned:</p>
<ul>
<li>INPUT: We are given a circuit, some inputs and compute an output value.</li>
<li>OUTPUT: We are then interested finding small changes to each input (independently) that would make the output higher.</li>
<li>Strategy #1: One silly way is to <strong>randomly search</strong> for small pertubations of the inputs and keep track of what gives the highest increase in output.</li>
<li>Strategy #2: We saw we can do much better by computing the gradient. Regardless of how complicated the circuit is, the <strong>numerical gradient</strong> is very simple (but relatively expensive) to compute. We compute it by <em>probing</em> the circuit&rsquo;s output value as we tweak the inputs one at a time.</li>
<li>Strategy #3: In the end, we saw that we can be even more clever and analytically derive a direct expression to get the <strong>analytic gradient</strong>. It is identical to the numerical gradient, it is fastest by far, and there is no need for any tweaking.</li>
</ul>
<p>In practice by the way (and we will get to this once again later), all Neural Network libraries always compute the analytic gradient, but the correctness of the implementation is verified by comparing it to the numerical gradient. That&rsquo;s because the numerical gradient is very easy to evaluate (but can be a bit expensive to compute), while the analytic gradient can contain bugs at times, but is usually extremely efficient to compute. As we will see, evaluating the gradient (i.e. while doing <em>backprop</em>, or <em>backward pass</em>) will turn out to cost about as much as evaluating the <em>forward pass</em>.</p>
<h3 id="recursive-case-circuits-with-multiple-gates">Recursive Case: Circuits with Multiple Gates</h3>
<p>But hold on, you say: <em>&ldquo;The analytic gradient was trivial to derive for your super-simple expression. This is useless. What do I do when the expressions are much larger? Don&rsquo;t the equations get huge and complex very fast?&rdquo;</em>. Good question. Yes the expressions get much more complex. No, this doesn&rsquo;t make it much harder. As we will see, every gate will be hanging out by itself, completely unaware of any details of the huge and complex circuit that it could be part of. It will only worry about its inputs and it will compute its local derivatives as seen in the previous section, except now there will be a single extra multiplication it will have to do.</p>
<blockquote>
<p>A single extra multiplication will turn a single (useless gate) into a cog in the complex machine that is an entire neural network.</p>
</blockquote>
<p>I should stop hyping it up now. I hope I&rsquo;ve piqued your interest! Lets drill down into details and get two gates involved with this next example:</p>
<div class="svgdiv">
<svg width="500" height="150">
  <rect x="130" y="20" width="100" height="100" stroke="black" stroke-width="1" fill="white" />
  <line x1="90" y1="45" x2="130" y2="45" stroke="black" stroke-width="1" />
  <line x1="90" y1="95" x2="130" y2="95" stroke="black" stroke-width="1" />
  <text x="70" y="50" fill="black" text-anchor="middle" font-size="20px">x</text>
  <text x="70" y="100" fill="black" text-anchor="middle" font-size="20px">y</text>
  <text x="70" y="150" fill="black" text-anchor="middle" font-size="20px">z</text>
<p><text x="180" y="85" fill="black" text-anchor="middle" font-size="40px">+</text>
<text x="270" y="60" fill="black" text-anchor="middle" font-size="20px">q</text></p>
  <line x1="230" y1="70" x2="320" y2="70" stroke="black" stroke-width="1" />
  <line x1="90" y1="145" x2="300" y2="145" stroke="black" stroke-width="1" />
  <line x1="300" y1="145" x2="300" y2="100" stroke="black" stroke-width="1" />
  <line x1="300" y1="100" x2="320" y2="100" stroke="black" stroke-width="1" />
  <rect x="320" y="32" width="100" height="100" stroke="black" stroke-width="1" fill="white" />
  <line x1="420" y1="82" x2="450" y2="82" stroke="black" stroke-width="1" />
<p><text x="370" y="105" fill="black" text-anchor="middle" font-size="40px">*</text>
<text x="460" y="88" fill="black" text-anchor="middle" font-size="20px">f</text>
</svg></p>
</div>
<p>The expression we are computing now is \( f(x,y,z) = (x + y) z \). Lets structure the code as follows to make the gates explicit as functions:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">forwardMultiplyGate</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">a</span> <span class="o">*</span> <span class="nx">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">forwardAddGate</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">forwardCircuit</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span><span class="nx">y</span><span class="p">,</span><span class="nx">z</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">  <span class="kd">var</span> <span class="nx">q</span> <span class="o">=</span> <span class="nx">forwardAddGate</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="nx">forwardMultiplyGate</span><span class="p">(</span><span class="nx">q</span><span class="p">,</span> <span class="nx">z</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="nx">z</span> <span class="o">=</span> <span class="o">-</span><span class="mi">4</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="nx">forwardCircuit</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">z</span><span class="p">);</span> <span class="c1">// output is -12
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>In the above, I am using <code>a</code> and <code>b</code> as the local variables in the gate functions so that we don&rsquo;t get these confused with our circuit inputs <code>x,y,z</code>. As before, we are interested in finding the derivatives with respect to the three inputs <code>x,y,z</code>. But how do we compute it now that there are multiple gates involved? First, lets pretend that the <code>+</code> gate is not there and that we only have two variables in the circuit: <code>q,z</code> and a single <code>*</code> gate. Note that the <code>q</code> is is output of the <code>+</code> gate. If we don&rsquo;t worry about <code>x</code> and <code>y</code> but only about <code>q</code> and <code>z</code>, then we are back to having only a single gate, and as far as that single <code>*</code> gate is concerned, we know what the (analytic) derivates are from previous section. We can write them down (except here we&rsquo;re replacing <code>x,y</code> with <code>q,z</code>):</p>
<p>$$
f(q,z) = q z \hspace{0.5in} \implies \hspace{0.5in} \frac{\partial f(q,z)}{\partial q} = z, \hspace{1in} \frac{\partial f(q,z)}{\partial z} = q
$$</p>
<p>Simple enough: these are the expressions for the gradient with respect to <code>q</code> and <code>z</code>. But wait, we don&rsquo;t want gradient with respect to <code>q</code>, but with respect to the inputs: <code>x</code> and <code>y</code>. Luckily, <code>q</code> is computed as a function of <code>x</code> and <code>y</code> (by addition in our example). We can write down the gradient for the addition gate as well, it&rsquo;s even simpler:</p>
<p>$$
q(x,y) = x + y \hspace{0.5in} \implies \hspace{0.5in} \frac{\partial q(x,y)}{\partial x} = 1, \hspace{1in} \frac{\partial q(x,y)}{\partial y} = 1
$$</p>
<p>That&rsquo;s right, the derivatives are just 1, regardless of the actual values of <code>x</code> and <code>y</code>. If you think about it, this makes sense because to make the output of a single addition gate higher, we expect a positive tug on both <code>x</code> and <code>y</code>, regardless of their values.</p>
<h4 id="backpropagation">Backpropagation</h4>
<p>We are finally ready to invoke the <strong>Chain Rule</strong>: We know how to compute the gradient of <code>q</code> with respect to <code>x</code> and <code>y</code> (that&rsquo;s a single gate case with <code>+</code> as the gate). And we know how to compute the gradient of our final output with respect to <code>q</code>. The chain rule tells us how to combine these to get the gradient of the final output with respect to <code>x</code> and <code>y</code>, which is what we&rsquo;re ultimately interested in. Best of all, the chain rule very simply states that the right thing to do is to simply multiply the gradients together to chain them. For example, the final derivative for <code>x</code> will be:</p>
<p>$$
\frac{\partial f(q,z)}{\partial x} = \frac{\partial q(x,y)}{\partial x} \frac{\partial f(q,z)}{\partial q}
$$</p>
<p>There are many symbols there so maybe this is confusing again, but it&rsquo;s really just two numbers being multiplied together. Here is the code:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="c1">// initial conditions
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="nx">z</span> <span class="o">=</span> <span class="o">-</span><span class="mi">4</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">q</span> <span class="o">=</span> <span class="nx">forwardAddGate</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">);</span> <span class="c1">// q is 3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="nx">forwardMultiplyGate</span><span class="p">(</span><span class="nx">q</span><span class="p">,</span> <span class="nx">z</span><span class="p">);</span> <span class="c1">// output is -12
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// gradient of the MULTIPLY gate with respect to its inputs
</span></span></span><span class="line"><span class="cl"><span class="c1">// wrt is short for &#34;with respect to&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">derivative_f_wrt_z</span> <span class="o">=</span> <span class="nx">q</span><span class="p">;</span> <span class="c1">// 3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">derivative_f_wrt_q</span> <span class="o">=</span> <span class="nx">z</span><span class="p">;</span> <span class="c1">// -4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// derivative of the ADD gate with respect to its inputs
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">derivative_q_wrt_x</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">derivative_q_wrt_y</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// chain rule
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">derivative_f_wrt_x</span> <span class="o">=</span> <span class="nx">derivative_q_wrt_x</span> <span class="o">*</span> <span class="nx">derivative_f_wrt_q</span><span class="p">;</span> <span class="c1">// -4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">derivative_f_wrt_y</span> <span class="o">=</span> <span class="nx">derivative_q_wrt_y</span> <span class="o">*</span> <span class="nx">derivative_f_wrt_q</span><span class="p">;</span> <span class="c1">// -4
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>That&rsquo;s it. We computed the gradient (the forces) and now we can let our inputs respond to it by a bit. Lets add the gradients on top of the inputs. The output value of the circuit better increase, up from -12!</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="c1">// final gradient, from above: [-4, -4, 3]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">gradient_f_wrt_xyz</span> <span class="o">=</span> <span class="p">[</span><span class="nx">derivative_f_wrt_x</span><span class="p">,</span> <span class="nx">derivative_f_wrt_y</span><span class="p">,</span> <span class="nx">derivative_f_wrt_z</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// let the inputs respond to the force/tug:
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">step_size</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">x</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">step_size</span> <span class="o">*</span> <span class="nx">derivative_f_wrt_x</span><span class="p">;</span> <span class="c1">// -2.04
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">y</span> <span class="o">=</span> <span class="nx">y</span> <span class="o">+</span> <span class="nx">step_size</span> <span class="o">*</span> <span class="nx">derivative_f_wrt_y</span><span class="p">;</span> <span class="c1">// 4.96
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">z</span> <span class="o">=</span> <span class="nx">z</span> <span class="o">+</span> <span class="nx">step_size</span> <span class="o">*</span> <span class="nx">derivative_f_wrt_z</span><span class="p">;</span> <span class="c1">// -3.97
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// Our circuit now better give higher output:
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">q</span> <span class="o">=</span> <span class="nx">forwardAddGate</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">);</span> <span class="c1">// q becomes 2.92
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="nx">forwardMultiplyGate</span><span class="p">(</span><span class="nx">q</span><span class="p">,</span> <span class="nx">z</span><span class="p">);</span> <span class="c1">// output is -11.59, up from -12! Nice!
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>Looks like that worked! Lets now try to interpret intuitively what just happened. The circuit wants to output higher values. The last gate saw inputs <code>q = 3, z = -4</code> and computed output <code>-12</code>. &ldquo;Pulling&rdquo; upwards on this output value induced a force on both <code>q</code> and <code>z</code>: To increase the output value, the circuit &ldquo;wants&rdquo; <code>z</code> to increase, as can be seen by the positive value of the derivative(<code>derivative_f_wrt_z = +3</code>). Again, the size of this derivative can be interpreted as the magnitude of the force. On the other hand, <code>q</code> felt a stronger and downward force, since <code>derivative_f_wrt_q = -4</code>. In other words the circuit wants <code>q</code> to decrease, with a force of <code>4</code>.</p>
<p>Now we get to the second, <code>+</code> gate which outputs <code>q</code>. By default, the <code>+</code> gate computes its derivatives which tells us how to change <code>x</code> and <code>y</code> to make <code>q</code> higher. BUT! Here is the <strong>crucial point</strong>: the gradient on <code>q</code> was computed as negative (<code>derivative_f_wrt_q = -4</code>), so the circuit wants <code>q</code> to <em>decrease</em>, and with a force of <code>4</code>! So if the <code>+</code> gate wants to contribute to making the final output value larger, it needs to listen to the gradient signal coming from the top. In this particular case, it needs to apply tugs on <code>x,y</code> opposite of what it would normally apply, and with a force of <code>4</code>, so to speak. The multiplication by <code>-4</code> seen in the chain rule achieves exactly this: instead of applying a positive force of <code>+1</code> on both <code>x</code> and <code>y</code> (the local derivative), the full circuit&rsquo;s gradient on both <code>x</code> and <code>y</code> becomes <code>1 x -4 = -4</code>. This makes sense: the circuit wants both <code>x</code> and <code>y</code> to get smaller because this will make <code>q</code> smaller, which in turn will make <code>f</code> larger.</p>
<blockquote>
<p>If this makes sense, you understand backpropagation.</p>
</blockquote>
<p>Lets <strong>recap</strong> once again what we learned:</p>
<ul>
<li>
<p>In the previous chapter we saw that in the case of a single gate (or a single expression), we can derive the analytic gradient using simple calculus. We interpreted the gradient as a force, or a tug on the inputs that pulls them in a direction which would make this gate&rsquo;s output higher.</p>
</li>
<li>
<p>In case of multiple gates everything stays pretty much the same way: every gate is hanging out by itself completely unaware of the circuit it is embedded in. Some inputs come in and the gate computes its output and the derivate with respect to the inputs. The <em>only</em> difference now is that suddenly, something can pull on this gate from above. That&rsquo;s the gradient of the final circuit output value with respect to the ouput this gate computed. It is the circuit asking the gate to output higher or lower numbers, and with some force. The gate simply takes this force and multiplies it to all the forces it computed for its inputs before (chain rule). This has the desired effect:</p>
</li>
</ul>
<ol>
<li>If a gate experiences a strong positive pull from above, it will also pull harder on its own inputs, scaled by the force it is experiencing from above</li>
<li>And if it experiences a negative tug, this means that circuit wants its value to decrease not increase, so it will flip the force of the pull on its inputs to make its own output value smaller.</li>
</ol>
<blockquote>
<p>A nice picture to have in mind is that as we pull on the circuit&rsquo;s output value at the end, this induces pulls downward through the entire circuit, all the way down to the inputs.</p>
</blockquote>
<p>Isn&rsquo;t it beautiful? The only difference between the case of a single gate and multiple interacting gates that compute arbitrarily complex expressions is this additional multipy operation that now happens in each gate.</p>
<h4 id="patterns-in-the-backward-flow">Patterns in the &ldquo;backward&rdquo; flow</h4>
<p>Lets look again at our example circuit with the numbers filled in. The first circuit shows the raw values, and the second circuit shows the gradients that flow back to the inputs as discussed. Notice that the gradient always starts off with <code>+1</code> at the end to start off the chain. This is the (default) pull on the circuit to have its value increased.</p>
<div class="svgdiv">
<svg width="600" height="350">
<p><text x="550" y="90" fill="black" text-anchor="middle" font-size="16px">(Values)</text>
<rect x="130" y="20" width="100" height="100" stroke="black" stroke-width="1" fill="white" />
<line x1="90" y1="45" x2="130" y2="45" stroke="black" stroke-width="1" />
<line x1="90" y1="95" x2="130" y2="95" stroke="black" stroke-width="1" />
<text x="70" y="50" fill="black" text-anchor="middle" font-size="20px">-2</text>
<text x="70" y="100" fill="black" text-anchor="middle" font-size="20px">5</text>
<text x="70" y="150" fill="black" text-anchor="middle" font-size="20px">-4</text></p>
<p><text x="180" y="85" fill="black" text-anchor="middle" font-size="40px">+</text>
<text x="270" y="60" fill="black" text-anchor="middle" font-size="20px">3</text></p>
  <line x1="230" y1="70" x2="320" y2="70" stroke="black" stroke-width="1" />
  <line x1="90" y1="145" x2="300" y2="145" stroke="black" stroke-width="1" />
  <line x1="300" y1="145" x2="300" y2="100" stroke="black" stroke-width="1" />
  <line x1="300" y1="100" x2="320" y2="100" stroke="black" stroke-width="1" />
  <rect x="320" y="32" width="100" height="100" stroke="black" stroke-width="1" fill="white" />
  <line x1="420" y1="82" x2="450" y2="82" stroke="black" stroke-width="1" />
<p><text x="370" y="105" fill="black" text-anchor="middle" font-size="40px">*</text>
<text x="460" y="88" fill="black" text-anchor="middle" font-size="20px">-12</text></p>
<p><text x="550" y="290" fill="black" text-anchor="middle" font-size="16px">(Gradients)</text>
<rect x="130" y="220" width="100" height="100" stroke="black" stroke-width="1" fill="white" />
<line x1="90" y1="245" x2="130" y2="245" stroke="black" stroke-width="1" />
<line x1="90" y1="295" x2="130" y2="295" stroke="black" stroke-width="1" />
<text x="70" y="250" fill="black" text-anchor="middle" font-size="20px">-4</text>
<text x="70" y="300" fill="black" text-anchor="middle" font-size="20px">-4</text>
<text x="70" y="350" fill="black" text-anchor="middle" font-size="20px">3</text></p>
<p><text x="180" y="285" fill="black" text-anchor="middle" font-size="40px">+</text>
<text x="270" y="260" fill="black" text-anchor="middle" font-size="20px">-4</text></p>
  <line x1="230" y1="270" x2="320" y2="270" stroke="black" stroke-width="1" />
  <line x1="90" y1="345" x2="300" y2="345" stroke="black" stroke-width="1" />
  <line x1="300" y1="345" x2="300" y2="300" stroke="black" stroke-width="1" />
  <line x1="300" y1="300" x2="320" y2="300" stroke="black" stroke-width="1" />
  <rect x="320" y="232" width="100" height="100" stroke="black" stroke-width="1" fill="white" />
  <line x1="420" y1="282" x2="450" y2="282" stroke="black" stroke-width="1" />
<p><text x="370" y="305" fill="black" text-anchor="middle" font-size="40px">*</text>
<text x="460" y="288" fill="black" text-anchor="middle" font-size="20px">1</text></p>
</svg>
</div>
<p>After a while you start to notice patterns in how the gradients flow backward in the circuits. For example, the <code>+</code> gate always takes the gradient on top and simply passes it on to all of its inputs (notice the example with -4 simply passed on to both of the inputs of <code>+</code> gate). This is because its own derivative for the inputs is just <code>+1</code>, regardless of what the actual values of the inputs are, so in the chain rule, the gradient from above is just multiplied by 1 and stays the same. Similar intuitions apply to, for example, a <code>max(x,y)</code> gate. Since the gradient of <code>max(x,y)</code> with respect to its input is <code>+1</code> for whichever one of <code>x</code>, <code>y</code> is larger and <code>0</code> for the other, this gate is during backprop effectively just a gradient &ldquo;switch&rdquo;: it will take the gradient from above and &ldquo;route&rdquo; it to the input that had a higher value during the forward pass.</p>
<p><strong>Numerical Gradient Check.</strong> Before we finish with this section, lets just make sure that the (analytic) gradient we computed by backprop above is correct as a sanity check. Remember that we can do this simply by computing the numerical gradient and making sure that we get <code>[-4, -4, 3]</code> for <code>x,y,z</code>. Here&rsquo;s the code:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="c1">// initial conditions
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="nx">z</span> <span class="o">=</span> <span class="o">-</span><span class="mi">4</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// numerical gradient check
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">h</span> <span class="o">=</span> <span class="mf">0.0001</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">x_derivative</span> <span class="o">=</span> <span class="p">(</span><span class="nx">forwardCircuit</span><span class="p">(</span><span class="nx">x</span><span class="o">+</span><span class="nx">h</span><span class="p">,</span><span class="nx">y</span><span class="p">,</span><span class="nx">z</span><span class="p">)</span> <span class="o">-</span> <span class="nx">forwardCircuit</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span><span class="nx">y</span><span class="p">,</span><span class="nx">z</span><span class="p">))</span> <span class="o">/</span> <span class="nx">h</span><span class="p">;</span> <span class="c1">// -4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">y_derivative</span> <span class="o">=</span> <span class="p">(</span><span class="nx">forwardCircuit</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span><span class="nx">y</span><span class="o">+</span><span class="nx">h</span><span class="p">,</span><span class="nx">z</span><span class="p">)</span> <span class="o">-</span> <span class="nx">forwardCircuit</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span><span class="nx">y</span><span class="p">,</span><span class="nx">z</span><span class="p">))</span> <span class="o">/</span> <span class="nx">h</span><span class="p">;</span> <span class="c1">// -4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">z_derivative</span> <span class="o">=</span> <span class="p">(</span><span class="nx">forwardCircuit</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span><span class="nx">y</span><span class="p">,</span><span class="nx">z</span><span class="o">+</span><span class="nx">h</span><span class="p">)</span> <span class="o">-</span> <span class="nx">forwardCircuit</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span><span class="nx">y</span><span class="p">,</span><span class="nx">z</span><span class="p">))</span> <span class="o">/</span> <span class="nx">h</span><span class="p">;</span> <span class="c1">// 3
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>and we get <code>[-4, -4, 3]</code>, as computed with backprop. phew! :)</p>
<h3 id="example-single-neuron">Example: Single Neuron</h3>
<p>In the previous section you hopefully got the basic intuition behind backpropagation. Lets now look at an even more complicated and borderline practical example. We will consider a 2-dimensional neuron that computes the following function:</p>
<p>$$
f(x,y,a,b,c) = \sigma(ax + by + c)
$$</p>
<p>In this expression, \( \sigma \) is the <em>sigmoid</em> function. Its best thought of as a &ldquo;squashing function&rdquo;, because it takes the input and squashes it to be between zero and one: Very negative values are squashed towards zero and positive values get squashed towards one. For example, we have <code>sig(-5) = 0.006, sig(0) = 0.5, sig(5) = 0.993</code>. Sigmoid function is defined as:</p>
<p>$$
\sigma(x) = \frac{1}{1 + e^{-x}}
$$</p>
<p>The gradient with respect to its single input, as you can check on Wikipedia or derive yourself if you know some calculus is given by this expression:</p>
<p>$$
\frac{\partial \sigma(x)}{\partial x} = \sigma(x) (1 - \sigma(x))
$$</p>
<p>For example, if the input to the sigmoid gate is <code>x = 3</code>, the gate will compute output <code>f = 1.0 / (1.0 + Math.exp(-x)) = 0.95</code>, and then the (local) gradient on its input will simply be <code>dx = (0.95) * (1 - 0.95) = 0.0475</code>.</p>
<p>That&rsquo;s all we need to use this gate: we know how to take an input and <em>forward</em> it through the sigmoid gate, and we also have the expression for the gradient with respect to its input, so we can also <em>backprop</em> through it. Another thing to note is that technically, the sigmoid function is made up of an entire series of gates in a line that compute more <em>atomic</em> functions: an exponentiation gate, an addition gate and a division gate. Treating it so would work perfectly fine but for this example I chose to collapse all of these gates into a single gate that just computes sigmoid in one shot, because the gradient expression turns out to be simple.</p>
<p>Lets take this opportunity to carefully structure the associated code in a nice and modular way. First, I&rsquo;d like you to note that every <strong>wire</strong> in our diagrams has two numbers associated with it:</p>
<ol>
<li>the value it carries during the forward pass</li>
<li>the gradient (i.e the <em>pull</em>) that flows back through it in the backward pass</li>
</ol>
<p>Lets create a simple <code>Unit</code> structure that will store these two values on every wire. Our gates will now operate over <code>Unit</code>s: they will take them as inputs and create them as outputs.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="c1">// every Unit corresponds to a wire in the diagrams
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">Unit</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">value</span><span class="p">,</span> <span class="nx">grad</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// value computed in the forward pass
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">this</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">  <span class="c1">// the derivative of circuit output w.r.t this unit, computed in backward pass
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">this</span><span class="p">.</span><span class="nx">grad</span> <span class="o">=</span> <span class="nx">grad</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>In addition to Units we also need 3 gates: <code>+</code>, <code>*</code> and <code>sig</code> (sigmoid). Lets start out by implementing a multiply gate. I&rsquo;m using Javascript here which has a funny way of simulating classes using functions. If you&rsquo;re not a Javascript - familiar person, all that&rsquo;s going on here is that I&rsquo;m defining a class that has certain properties (accessed with use of <code>this</code> keyword), and some methods (which in Javascript are placed into the function&rsquo;s <em>prototype</em>). Just think about these as class methods. Also keep in mind that the way we will use these eventually is that we will first <code>forward</code> all the gates one by one, and then <code>backward</code> all the gates in reverse order. Here is the implementation:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">multiplyGate</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nx">multiplyGate</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">forward</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">u0</span><span class="p">,</span> <span class="nx">u1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// store pointers to input Units u0 and u1 and output unit utop
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">this</span><span class="p">.</span><span class="nx">u0</span> <span class="o">=</span> <span class="nx">u0</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">u1</span> <span class="o">=</span> <span class="nx">u1</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">utop</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Unit</span><span class="p">(</span><span class="nx">u0</span><span class="p">.</span><span class="nx">value</span> <span class="o">*</span> <span class="nx">u1</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">utop</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span>
</span></span><span class="line"><span class="cl">  <span class="nx">backward</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// take the gradient in output unit and chain it with the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// local gradients, which we derived for multiply gate before
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// then write those gradients to those Units.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">this</span><span class="p">.</span><span class="nx">u0</span><span class="p">.</span><span class="nx">grad</span> <span class="o">+=</span> <span class="k">this</span><span class="p">.</span><span class="nx">u1</span><span class="p">.</span><span class="nx">value</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">utop</span><span class="p">.</span><span class="nx">grad</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">u1</span><span class="p">.</span><span class="nx">grad</span> <span class="o">+=</span> <span class="k">this</span><span class="p">.</span><span class="nx">u0</span><span class="p">.</span><span class="nx">value</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">utop</span><span class="p">.</span><span class="nx">grad</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>The multiply gate takes two units that each hold a value and creates a unit that stores its output. The gradient is initialized to zero. Then notice that in the <code>backward</code> function call we get the gradient from the output unit we produced during the forward pass (which will by now hopefully have its gradient filled in) and multiply it with the local gradient for this gate (chain rule!). This gate computes multiplication (<code>u0.value * u1.value</code>) during forward pass, so recall that the gradient w.r.t <code>u0</code> is <code>u1.value</code> and w.r.t <code>u1</code> is <code>u0.value</code>. Also note that we are using <code>+=</code> to add onto the gradient in the <code>backward</code> function. This will allow us to possibly use the output of one gate multiple times (think of it as a wire branching out), since it turns out that the gradients from these different branches just add up when computing the final gradient with respect to the circuit output. The other two gates are defined analogously:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">addGate</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nx">addGate</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">forward</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">u0</span><span class="p">,</span> <span class="nx">u1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">u0</span> <span class="o">=</span> <span class="nx">u0</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">u1</span> <span class="o">=</span> <span class="nx">u1</span><span class="p">;</span> <span class="c1">// store pointers to input units
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">this</span><span class="p">.</span><span class="nx">utop</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Unit</span><span class="p">(</span><span class="nx">u0</span><span class="p">.</span><span class="nx">value</span> <span class="o">+</span> <span class="nx">u1</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">utop</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span>
</span></span><span class="line"><span class="cl">  <span class="nx">backward</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// add gate. derivative wrt both inputs is 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">this</span><span class="p">.</span><span class="nx">u0</span><span class="p">.</span><span class="nx">grad</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">utop</span><span class="p">.</span><span class="nx">grad</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">u1</span><span class="p">.</span><span class="nx">grad</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">utop</span><span class="p">.</span><span class="nx">grad</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">sigmoidGate</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">  <span class="c1">// helper function
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">this</span><span class="p">.</span><span class="nx">sig</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">exp</span><span class="p">(</span><span class="o">-</span><span class="nx">x</span><span class="p">));</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nx">sigmoidGate</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">forward</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">u0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">u0</span> <span class="o">=</span> <span class="nx">u0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">utop</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Unit</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">sig</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">u0</span><span class="p">.</span><span class="nx">value</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">utop</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span>
</span></span><span class="line"><span class="cl">  <span class="nx">backward</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">s</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">sig</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">u0</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">u0</span><span class="p">.</span><span class="nx">grad</span> <span class="o">+=</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="nx">s</span><span class="p">))</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">utop</span><span class="p">.</span><span class="nx">grad</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Note that, again, the <code>backward</code> function in all cases just computes the local derivative with respect to its input and then multiplies on the gradient from the unit above (i.e. chain rule). To fully specify everything lets finally write out the forward and backward flow for our 2-dimensional neuron with some example values:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="c1">// create input units
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Unit</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Unit</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">c</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Unit</span><span class="p">(</span><span class="o">-</span><span class="mf">3.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Unit</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">y</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Unit</span><span class="p">(</span><span class="mf">3.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// create the gates
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">mulg0</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">multiplyGate</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">mulg1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">multiplyGate</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">addg0</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">addGate</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">addg1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">addGate</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">sg0</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">sigmoidGate</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// do the forward pass
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">forwardNeuron</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">ax</span> <span class="o">=</span> <span class="nx">mulg0</span><span class="p">.</span><span class="nx">forward</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">x</span><span class="p">);</span> <span class="c1">// a*x = -1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">by</span> <span class="o">=</span> <span class="nx">mulg1</span><span class="p">.</span><span class="nx">forward</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="nx">y</span><span class="p">);</span> <span class="c1">// b*y = 6
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">axpby</span> <span class="o">=</span> <span class="nx">addg0</span><span class="p">.</span><span class="nx">forward</span><span class="p">(</span><span class="nx">ax</span><span class="p">,</span> <span class="nx">by</span><span class="p">);</span> <span class="c1">// a*x + b*y = 5
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">axpbypc</span> <span class="o">=</span> <span class="nx">addg1</span><span class="p">.</span><span class="nx">forward</span><span class="p">(</span><span class="nx">axpby</span><span class="p">,</span> <span class="nx">c</span><span class="p">);</span> <span class="c1">// a*x + b*y + c = 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">s</span> <span class="o">=</span> <span class="nx">sg0</span><span class="p">.</span><span class="nx">forward</span><span class="p">(</span><span class="nx">axpbypc</span><span class="p">);</span> <span class="c1">// sig(a*x + b*y + c) = 0.8808
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nx">forwardNeuron</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;circuit output: &#39;</span> <span class="o">+</span> <span class="nx">s</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span> <span class="c1">// prints 0.8808
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>And now lets compute the gradient: Simply iterate in reverse order and call the <code>backward</code> function! Remember that we stored the pointers to the units when we did the forward pass, so every gate has access to its inputs and also the output unit it previously produced.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="nx">s</span><span class="p">.</span><span class="nx">grad</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">sg0</span><span class="p">.</span><span class="nx">backward</span><span class="p">();</span> <span class="c1">// writes gradient into axpbypc
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">addg1</span><span class="p">.</span><span class="nx">backward</span><span class="p">();</span> <span class="c1">// writes gradients into axpby and c
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">addg0</span><span class="p">.</span><span class="nx">backward</span><span class="p">();</span> <span class="c1">// writes gradients into ax and by
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">mulg1</span><span class="p">.</span><span class="nx">backward</span><span class="p">();</span> <span class="c1">// writes gradients into b and y
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">mulg0</span><span class="p">.</span><span class="nx">backward</span><span class="p">();</span> <span class="c1">// writes gradients into a and x
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>Note that the first line sets the gradient at the output (very last unit) to be <code>1.0</code> to start off the gradient chain. This can be interpreted as tugging on the last gate with a force of <code>+1</code>. In other words, we are pulling on the entire circuit to induce the forces that will increase the output value. If we did not set this to 1, all gradients would be computed as zero due to the multiplications in the chain rule. Finally, lets make the inputs respond to the computed gradients and check that the function increased:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">step_size</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">a</span><span class="p">.</span><span class="nx">value</span> <span class="o">+=</span> <span class="nx">step_size</span> <span class="o">*</span> <span class="nx">a</span><span class="p">.</span><span class="nx">grad</span><span class="p">;</span> <span class="c1">// a.grad is -0.105
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">b</span><span class="p">.</span><span class="nx">value</span> <span class="o">+=</span> <span class="nx">step_size</span> <span class="o">*</span> <span class="nx">b</span><span class="p">.</span><span class="nx">grad</span><span class="p">;</span> <span class="c1">// b.grad is 0.315
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">c</span><span class="p">.</span><span class="nx">value</span> <span class="o">+=</span> <span class="nx">step_size</span> <span class="o">*</span> <span class="nx">c</span><span class="p">.</span><span class="nx">grad</span><span class="p">;</span> <span class="c1">// c.grad is 0.105
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">x</span><span class="p">.</span><span class="nx">value</span> <span class="o">+=</span> <span class="nx">step_size</span> <span class="o">*</span> <span class="nx">x</span><span class="p">.</span><span class="nx">grad</span><span class="p">;</span> <span class="c1">// x.grad is 0.105
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">y</span><span class="p">.</span><span class="nx">value</span> <span class="o">+=</span> <span class="nx">step_size</span> <span class="o">*</span> <span class="nx">y</span><span class="p">.</span><span class="nx">grad</span><span class="p">;</span> <span class="c1">// y.grad is 0.210
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">forwardNeuron</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;circuit output after one backprop: &#39;</span> <span class="o">+</span> <span class="nx">s</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span> <span class="c1">// prints 0.8825
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>Success! <code>0.8825</code> is higher than the previous value, <code>0.8808</code>. Finally, lets verify that we implemented the backpropagation correctly by checking the numerical gradient:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">forwardCircuitFast</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">,</span><span class="nx">c</span><span class="p">,</span><span class="nx">x</span><span class="p">,</span><span class="nx">y</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">exp</span><span class="p">(</span> <span class="o">-</span> <span class="p">(</span><span class="nx">a</span><span class="o">*</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">b</span><span class="o">*</span><span class="nx">y</span> <span class="o">+</span> <span class="nx">c</span><span class="p">)));</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="nx">c</span> <span class="o">=</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="nx">x</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">h</span> <span class="o">=</span> <span class="mf">0.0001</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">a_grad</span> <span class="o">=</span> <span class="p">(</span><span class="nx">forwardCircuitFast</span><span class="p">(</span><span class="nx">a</span><span class="o">+</span><span class="nx">h</span><span class="p">,</span><span class="nx">b</span><span class="p">,</span><span class="nx">c</span><span class="p">,</span><span class="nx">x</span><span class="p">,</span><span class="nx">y</span><span class="p">)</span> <span class="o">-</span> <span class="nx">forwardCircuitFast</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">,</span><span class="nx">c</span><span class="p">,</span><span class="nx">x</span><span class="p">,</span><span class="nx">y</span><span class="p">))</span><span class="o">/</span><span class="nx">h</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">b_grad</span> <span class="o">=</span> <span class="p">(</span><span class="nx">forwardCircuitFast</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="o">+</span><span class="nx">h</span><span class="p">,</span><span class="nx">c</span><span class="p">,</span><span class="nx">x</span><span class="p">,</span><span class="nx">y</span><span class="p">)</span> <span class="o">-</span> <span class="nx">forwardCircuitFast</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">,</span><span class="nx">c</span><span class="p">,</span><span class="nx">x</span><span class="p">,</span><span class="nx">y</span><span class="p">))</span><span class="o">/</span><span class="nx">h</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">c_grad</span> <span class="o">=</span> <span class="p">(</span><span class="nx">forwardCircuitFast</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">,</span><span class="nx">c</span><span class="o">+</span><span class="nx">h</span><span class="p">,</span><span class="nx">x</span><span class="p">,</span><span class="nx">y</span><span class="p">)</span> <span class="o">-</span> <span class="nx">forwardCircuitFast</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">,</span><span class="nx">c</span><span class="p">,</span><span class="nx">x</span><span class="p">,</span><span class="nx">y</span><span class="p">))</span><span class="o">/</span><span class="nx">h</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">x_grad</span> <span class="o">=</span> <span class="p">(</span><span class="nx">forwardCircuitFast</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">,</span><span class="nx">c</span><span class="p">,</span><span class="nx">x</span><span class="o">+</span><span class="nx">h</span><span class="p">,</span><span class="nx">y</span><span class="p">)</span> <span class="o">-</span> <span class="nx">forwardCircuitFast</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">,</span><span class="nx">c</span><span class="p">,</span><span class="nx">x</span><span class="p">,</span><span class="nx">y</span><span class="p">))</span><span class="o">/</span><span class="nx">h</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">y_grad</span> <span class="o">=</span> <span class="p">(</span><span class="nx">forwardCircuitFast</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">,</span><span class="nx">c</span><span class="p">,</span><span class="nx">x</span><span class="p">,</span><span class="nx">y</span><span class="o">+</span><span class="nx">h</span><span class="p">)</span> <span class="o">-</span> <span class="nx">forwardCircuitFast</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">,</span><span class="nx">c</span><span class="p">,</span><span class="nx">x</span><span class="p">,</span><span class="nx">y</span><span class="p">))</span><span class="o">/</span><span class="nx">h</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Indeed, these all give the same values as the backpropagated gradients <code>[-0.105, 0.315, 0.105, 0.105, 0.210]</code>. Nice!</p>
<p>I hope it is clear that even though we only looked at an example of a single neuron, the code I gave above generalizes in a very straight-forward way to compute gradients of arbitrary expressions (including very deep expressions #foreshadowing). All you have to do is write small gates that compute local, simple derivatives w.r.t their inputs, wire it up in a graph, do a forward pass to compute the output value and then a backward pass that chains the gradients all the way to the input.</p>
<h3 id="becoming-a-backprop-ninja">Becoming a Backprop Ninja</h3>
<p>Over time you will become much more efficient in writing the backward pass, even for complicated circuits and all at once. Lets practice backprop a bit with a few examples. In what follows, lets not worry about Unit, Circuit classes because they obfuscate things a bit, and lets just use variables such as <code>a,b,c,x</code>, and refer to their gradients as <code>da,db,dc,dx</code> respectively. Again, we think of the variables as the &ldquo;forward flow&rdquo; and their gradients as &ldquo;backward flow&rdquo; along every wire. Our first example was the <code>*</code> gate:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">a</span> <span class="o">*</span> <span class="nx">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// and given gradient on x (dx), we saw that in backprop we would compute:
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">da</span> <span class="o">=</span> <span class="nx">b</span> <span class="o">*</span> <span class="nx">dx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">db</span> <span class="o">=</span> <span class="nx">a</span> <span class="o">*</span> <span class="nx">dx</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>In the code above, I&rsquo;m assuming that the variable <code>dx</code> is given, coming from somewhere above us in the circuit while we&rsquo;re doing backprop (or it is +1 by default otherwise). I&rsquo;m writing it out because I want to explicitly show how the gradients get chained together. Note from the equations that the <code>*</code> gate acts as a <em>switcher</em> during backward pass, for lack of better word. It remembers what its inputs were, and the gradients on each one will be the value of the other during the forward pass. And then of course we have to multiply with the gradient from above, which is the chain rule. Here&rsquo;s the <code>+</code> gate in this condensed form:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// -&gt;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">da</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="nx">dx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">db</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="nx">dx</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Where <code>1.0</code> is the local gradient, and the multiplication is our chain rule. What about adding three numbers?:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="c1">// lets compute x = a + b + c in two steps:
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">q</span> <span class="o">=</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span><span class="p">;</span> <span class="c1">// gate 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">q</span> <span class="o">+</span> <span class="nx">c</span><span class="p">;</span> <span class="c1">// gate 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// backward pass:
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">dc</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="nx">dx</span><span class="p">;</span> <span class="c1">// backprop gate 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">dq</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="nx">dx</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="nx">da</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="nx">dq</span><span class="p">;</span> <span class="c1">// backprop gate 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">db</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="nx">dq</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>You can see what&rsquo;s happening, right? If you remember the backward flow diagram, the <code>+</code> gate simply takes the gradient on top and routes it equally to all of its inputs (because its local gradient is always simply <code>1.0</code> for all its inputs, regardless of their actual values). So we can do it much faster:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span> <span class="o">+</span> <span class="nx">c</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">da</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="nx">dx</span><span class="p">;</span> <span class="kd">var</span> <span class="nx">db</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="nx">dx</span><span class="p">;</span> <span class="kd">var</span> <span class="nx">dc</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="nx">dx</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Okay, how about combining gates?:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">a</span> <span class="o">*</span> <span class="nx">b</span> <span class="o">+</span> <span class="nx">c</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// given dx, backprop in-one-sweep would be =&gt;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">da</span> <span class="o">=</span> <span class="nx">b</span> <span class="o">*</span> <span class="nx">dx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">db</span> <span class="o">=</span> <span class="nx">a</span> <span class="o">*</span> <span class="nx">dx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">dc</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="nx">dx</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>If you don&rsquo;t see how the above happened, introduce a temporary variable <code>q = a * b</code> and then compute <code>x = q + c</code> to convince yourself. And here is our neuron, lets do it in two steps:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="c1">// lets do our neuron in two steps:
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">q</span> <span class="o">=</span> <span class="nx">a</span><span class="o">*</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">b</span><span class="o">*</span><span class="nx">y</span> <span class="o">+</span> <span class="nx">c</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="nx">sig</span><span class="p">(</span><span class="nx">q</span><span class="p">);</span> <span class="c1">// sig is the sigmoid function
</span></span></span><span class="line"><span class="cl"><span class="c1">// and now backward pass, we are given df, and:
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">df</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">dq</span> <span class="o">=</span> <span class="p">(</span><span class="nx">f</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="nx">f</span><span class="p">))</span> <span class="o">*</span> <span class="nx">df</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// and now we chain it to the inputs
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">da</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">dq</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">dx</span> <span class="o">=</span> <span class="nx">a</span> <span class="o">*</span> <span class="nx">dq</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">dy</span> <span class="o">=</span> <span class="nx">b</span> <span class="o">*</span> <span class="nx">dq</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">db</span> <span class="o">=</span> <span class="nx">y</span> <span class="o">*</span> <span class="nx">dq</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">dc</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="nx">dq</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>I hope this is starting to make a little more sense. Now how about this:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">a</span> <span class="o">*</span> <span class="nx">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">da</span> <span class="o">=</span> <span class="c1">//???
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>You can think of this as value <code>a</code> flowing to the <code>*</code> gate, but the wire gets split and becomes both inputs. This is actually simple because the backward flow of gradients always adds up. In other words nothing changes:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">da</span> <span class="o">=</span> <span class="nx">a</span> <span class="o">*</span> <span class="nx">dx</span><span class="p">;</span> <span class="c1">// gradient into a from first branch
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">da</span> <span class="o">+=</span> <span class="nx">a</span> <span class="o">*</span> <span class="nx">dx</span><span class="p">;</span> <span class="c1">// and add on the gradient from the second branch
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// short form instead is:
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">da</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="nx">a</span> <span class="o">*</span> <span class="nx">dx</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>In fact, if you know your power rule from calculus you would also know that if you have \( f(a) = a^2 \) then \( \frac{\partial f(a)}{\partial a} = 2a \), which is exactly what we get if we think of it as wire splitting up and being two inputs to a gate.</p>
<p>Lets do another one:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">a</span><span class="o">*</span><span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span><span class="o">*</span><span class="nx">b</span> <span class="o">+</span> <span class="nx">c</span><span class="o">*</span><span class="nx">c</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// we get:
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">da</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="nx">a</span><span class="o">*</span><span class="nx">dx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">db</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="nx">b</span><span class="o">*</span><span class="nx">dx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">dc</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="nx">c</span><span class="o">*</span><span class="nx">dx</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Okay now lets start to get more complex:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">pow</span><span class="p">(((</span><span class="nx">a</span> <span class="o">*</span> <span class="nx">b</span> <span class="o">+</span> <span class="nx">c</span><span class="p">)</span> <span class="o">*</span> <span class="nx">d</span><span class="p">),</span> <span class="mi">2</span><span class="p">);</span> <span class="c1">// pow(x,2) squares the input JS
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>When more complex cases like this come up in practice, I like to split the expression into manageable chunks which are almost always composed of simpler expressions and then I chain them together with chain rule:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">x1</span> <span class="o">=</span> <span class="nx">a</span> <span class="o">*</span> <span class="nx">b</span> <span class="o">+</span> <span class="nx">c</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">x2</span> <span class="o">=</span> <span class="nx">x1</span> <span class="o">*</span> <span class="nx">d</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">x2</span> <span class="o">*</span> <span class="nx">x2</span><span class="p">;</span> <span class="c1">// this is identical to the above expression for x
</span></span></span><span class="line"><span class="cl"><span class="c1">// and now in backprop we go backwards:
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">dx2</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="nx">x2</span> <span class="o">*</span> <span class="nx">dx</span><span class="p">;</span> <span class="c1">// backprop into x2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">dd</span> <span class="o">=</span> <span class="nx">x1</span> <span class="o">*</span> <span class="nx">dx2</span><span class="p">;</span> <span class="c1">// backprop into d
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">dx1</span> <span class="o">=</span> <span class="nx">d</span> <span class="o">*</span> <span class="nx">dx2</span><span class="p">;</span> <span class="c1">// backprop into x1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">da</span> <span class="o">=</span> <span class="nx">b</span> <span class="o">*</span> <span class="nx">dx1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">db</span> <span class="o">=</span> <span class="nx">a</span> <span class="o">*</span> <span class="nx">dx1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">dc</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="nx">dx1</span><span class="p">;</span> <span class="c1">// done!
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>That wasn&rsquo;t too difficult! Those are the backprop equations for the entire expression, and we&rsquo;ve done them piece by piece and backpropped to all the variables. Notice again how for every variable during forward pass we have an equivalent variable during backward pass that contains its gradient with respect to the circuit&rsquo;s final output. Here are a few more useful functions and their local gradients that are useful in practice:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="nx">a</span><span class="p">;</span> <span class="c1">// division
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">da</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="nx">a</span><span class="o">*</span><span class="nx">a</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Here&rsquo;s what division might look like in practice then:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="p">(</span><span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="nx">c</span> <span class="o">+</span> <span class="nx">d</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// lets decompose it in steps:
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">x1</span> <span class="o">=</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">x2</span> <span class="o">=</span> <span class="nx">c</span> <span class="o">+</span> <span class="nx">d</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">x3</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="nx">x2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">x1</span> <span class="o">*</span> <span class="nx">x3</span><span class="p">;</span> <span class="c1">// equivalent to above
</span></span></span><span class="line"><span class="cl"><span class="c1">// and now backprop, again in reverse order:
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">dx1</span> <span class="o">=</span> <span class="nx">x3</span> <span class="o">*</span> <span class="nx">dx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">dx3</span> <span class="o">=</span> <span class="nx">x1</span> <span class="o">*</span> <span class="nx">dx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">dx2</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="nx">x2</span><span class="o">*</span><span class="nx">x2</span><span class="p">))</span> <span class="o">*</span> <span class="nx">dx3</span><span class="p">;</span> <span class="c1">// local gradient as shown above, and chain rule
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">da</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="nx">dx1</span><span class="p">;</span> <span class="c1">// and finally into the original variables
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">db</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="nx">dx1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">dc</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="nx">dx2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">dd</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="nx">dx2</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Hopefully you see that we are breaking down expressions, doing the forward pass, and then for every variable (such as <code>a</code>) we derive its gradient <code>da</code> as we go backwards, one by one, applying the simple local gradients and chaining them with gradients from above. Here&rsquo;s another one:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">da</span> <span class="o">=</span> <span class="nx">a</span> <span class="o">===</span> <span class="nx">x</span> <span class="o">?</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="nx">dx</span> <span class="o">:</span> <span class="mf">0.0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">db</span> <span class="o">=</span> <span class="nx">b</span> <span class="o">===</span> <span class="nx">x</span> <span class="o">?</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="nx">dx</span> <span class="o">:</span> <span class="mf">0.0</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Okay this is making a very simple thing hard to read. The <code>max</code> function passes on the value of the input that was largest and ignores the other ones. In the backward pass then, the max gate will simply take the gradient on top and route it to the input that actually flowed through it during the forward pass. The gate acts as a simple switch based on which input had the highest value during forward pass. The other inputs will have zero gradient. That&rsquo;s what the <code>===</code> is about, since we are testing for which input was the actual max and only routing the gradient to it.</p>
<p>Finally, lets look at the Rectified Linear Unit non-linearity (or ReLU), which you may have heard of. It is used in Neural Networks in place of the sigmoid function. It is simply thresholding at zero:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// backprop through this gate will then be:
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">da</span> <span class="o">=</span> <span class="nx">a</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="nx">dx</span> <span class="o">:</span> <span class="mf">0.0</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>In other words this gate simply passes the value through if it&rsquo;s larger than 0, or it stops the flow and sets it to zero. In the backward pass, the gate will pass on the gradient from the top if it was activated during the forawrd pass, or if the original input was below zero, it will stop the gradient flow.</p>
<p>I will stop at this point. I hope you got some intuition about how you can compute entire expressions (which are made up of many gates along the way) and how you can compute backprop for every one of them.</p>
<p>Everything we&rsquo;ve done in this chapter comes down to this: We saw that we can feed some input through arbitrarily complex real-valued circuit, tug at the end of the circuit with some force, and backpropagation distributes that tug through the entire circuit all the way back to the inputs. If the inputs respond slightly along the final direction of their tug, the circuit will &ldquo;give&rdquo; a bit along the original pull direction. Maybe this is not immediately obvious, but this machinery is a powerful <em>hammer</em> for Machine Learning.</p>
<blockquote>
<p>&ldquo;Maybe this is not immediately obvious, but this machinery is a powerful <em>hammer</em> for Machine Learning.&rdquo;</p>
</blockquote>
<p>Lets now put this machinery to good use.</p>
<h2 id="chapter-2-machine-learning">Chapter 2: Machine Learning</h2>
<p>In the last chapter we were concerned with real-valued circuits that computed possibly complex expressions of their inputs (the forward pass), and also we could compute the gradients of these expressions on the original inputs (backward pass). In this chapter we will see how useful this extremely simple mechanism is in Machine Learning.</p>
<h3 id="binary-classification">Binary Classification</h3>
<p>As we did before, lets start out simple. The simplest, common and yet very practical problem in Machine Learning is <strong>binary classification</strong>. A lot of very interesting and important problems can be reduced to it. The setup is as follows: We are given a dataset of <code>N</code> vectors and every one of them is labeled with a <code>+1</code> or a <code>-1</code>. For example, in two dimensions our dataset could look as simple as:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">vector -&gt; label
</span></span><span class="line"><span class="cl">---------------
</span></span><span class="line"><span class="cl">[1.2, 0.7] -&gt; +1
</span></span><span class="line"><span class="cl">[-0.3, 0.5] -&gt; -1
</span></span><span class="line"><span class="cl">[-3, -1] -&gt; +1
</span></span><span class="line"><span class="cl">[0.1, 1.0] -&gt; -1
</span></span><span class="line"><span class="cl">[3.0, 1.1] -&gt; -1
</span></span><span class="line"><span class="cl">[2.1, -3] -&gt; +1
</span></span></code></pre></td></tr></table>
</div>
</div><p>Here, we have <code>N = 6</code> <strong>datapoints</strong>, where every datapoint has two <strong>features</strong> (<code>D = 2</code>). Three of the datapoints have <strong>label</strong> <code>+1</code> and the other three label <code>-1</code>. This is a silly toy example, but in practice a +1/-1 dataset could be very useful things indeed: For example spam/no spam emails, where the vectors somehow measure various features of the content of the email, such as the number of times certain enhancement drugs are mentioned.</p>
<p><strong>Goal</strong>. Our goal in binary classification is to learn a function that takes a 2-dimensional vector and predicts the label. This function is usually parameterized by a certain set of parameters, and we will want to tune the parameters of the function so that its outputs are consistent with the labeling in the provided dataset. In the end we can discard the dataset and use the learned parameters to predict labels for previously unseen vectors.</p>
<h4 id="training-protocol">Training protocol</h4>
<p>We will eventually build up to entire neural networks and complex expressions, but lets start out simple and train a linear classifier very similar to the single neuron we saw at the end of Chapter 1. The only difference is that we&rsquo;ll get rid of the sigmoid because it makes things unnecessarily complicated (I only used it as an example in Chapter 1 because sigmoid neurons are historically popular but modern Neural Networks rarely, if ever, use sigmoid non-linearities). Anyway, lets use a simple linear function:</p>
<p>$$
f(x, y) = ax + by + c
$$</p>
<p>In this expression we think of <code>x</code> and <code>y</code> as the inputs (the 2D vectors) and <code>a,b,c</code> as the parameters of the function that we will want to learn. For example, if <code>a = 1, b = -2, c = -1</code>, then the function will take the first datapoint (<code>[1.2, 0.7]</code>) and output <code>1 * 1.2 + (-2) * 0.7 + (-1) = -1.2</code>. Here is how the training will work:</p>
<ol>
<li>We select a random datapoint and feed it through the circuit</li>
<li>We will interpret the output of the circuit as a confidence that the datapoint has class <code>+1</code>. (i.e. very high values = circuit is very certain datapoint has class <code>+1</code> and very low values = circuit is certain this datapoint has class <code>-1</code>.)</li>
<li>We will measure how well the prediction aligns with the provided labels. Intuitively, for example, if a positive example scores very low, we will want to tug in the positive direction on the circuit, demanding that it should output higher value for this datapoint. Note that this is the case for the the first datapoint: it is labeled as <code>+1</code> but our predictor unction only assigns it value <code>-1.2</code>. We will therefore tug on the circuit in positive direction; We want the value to be higher.</li>
<li>The circuit will take the tug and backpropagate it to compute tugs on the inputs <code>a,b,c,x,y</code></li>
<li>Since we think of <code>x,y</code> as (fixed) datapoints, we will ignore the pull on <code>x,y</code>. If you&rsquo;re a fan of my physical analogies, think of these inputs as pegs, fixed in the ground.</li>
<li>On the other hand, we will take the parameters <code>a,b,c</code> and make them respond to their tug (i.e. we&rsquo;ll perform what we call a <strong>parameter update</strong>). This, of course, will make it so that the circuit will output a slightly higher score on this particular datapoint in the future.</li>
<li>Iterate! Go back to step 1.</li>
</ol>
<p>The training scheme I described above, is commonly referred as <strong>Stochastic Gradient Descent</strong>. The interesting part I&rsquo;d like to reiterate is that <code>a,b,c,x,y</code> are all made up of the same <em>stuff</em> as far as the circuit is concerned: They are inputs to the circuit and the circuit will tug on all of them in some direction. It doesn&rsquo;t know the difference between parameters and datapoints. However, after the backward pass is complete we ignore all tugs on the datapoints (<code>x,y</code>) and keep swapping them in and out as we iterate over examples in the dataset. On the other hand, we keep the parameters (<code>a,b,c</code>) around and keep tugging on them every time we sample a datapoint. Over time, the pulls on these parameters will tune these values in such a way that the function outputs high scores for positive examples and low scores for negative examples.</p>
<h4 id="learning-a-support-vector-machine">Learning a Support Vector Machine</h4>
<p>As a concrete example, lets learn a <strong>Support Vector Machine</strong>. The SVM is a very popular linear classifier; Its functional form is exactly as I&rsquo;ve described in previous section, \( f(x,y) = ax + by + c\). At this point, if you&rsquo;ve seen an explanation of SVMs you&rsquo;re probably expecting me to define the SVM loss function and plunge into an explanation of slack variables, geometrical intuitions of large margins, kernels, duality, etc. But here, I&rsquo;d like to take a different approach. Instead of definining loss functions, I would like to base the explanation on the <em>force specification</em> (I just made this term up by the way) of a Support Vector Machine, which I personally find much more intuitive. As we will see, talking about the force specification and the loss function are identical ways of seeing the same problem. Anyway, here it is:</p>
<p><strong>Support Vector Machine &ldquo;Force Specification&rdquo;:</strong></p>
<ul>
<li>If we feed a positive datapoint through the SVM circuit and the output value is less than 1, pull on the circuit with force <code>+1</code>. This is a positive example so we want the score to be higher for it.</li>
<li>Conversely, if we feed a negative datapoint through the SVM and the output is greater than -1, then the circuit is giving this datapoint dangerously high score: Pull on the circuit downwards with force <code>-1</code>.</li>
<li>In addition to the pulls above, always add a small amount of pull on the parameters <code>a,b</code> (notice, not on <code>c</code>!) that pulls them towards zero. You can think of both <code>a,b</code> as being attached to a physical spring that is attached at zero. Just as with a physical spring, this will make the pull proprotional to the value of each of <code>a,b</code> (Hooke&rsquo;s law in physics, anyone?). For example, if <code>a</code> becomes very high it will experience a strong pull of magnitude <code>|a|</code> back towards zero. This pull is something we call <strong>regularization</strong>, and it ensures that neither of our parameters <code>a</code> or <code>b</code> gets disproportionally large. This would be undesirable because both <code>a,b</code> get multiplied to the input features <code>x,y</code> (remember the equation is <code>a*x + b*y + c</code>), so if either of them is too high, our classifier would be overly sensitive to these features. This isn&rsquo;t a nice property because features can often be noisy in practice, so we want our classifier to change relatively smoothly if they wiggle around.</li>
</ul>
<p>Lets quickly go through a small but concrete example. Suppose we start out with a random parameter setting, say, <code>a = 1, b = -2, c = -1</code>. Then:</p>
<ul>
<li>If we feed the point <code>[1.2, 0.7]</code>, the SVM will compute score <code>1 * 1.2 + (-2) * 0.7 - 1 = -1.2</code>. This point is labeled as <code>+1</code> in the training data, so we want the score to be higher than 1. The gradient on top of the circuit will thus be positive: <code>+1</code>, which will backpropagate to <code>a,b,c</code>. Additionally, there will also be a regularization pull on <code>a</code> of <code>-1</code> (to make it smaller) and regularization pull on <code>b</code> of <code>+2</code> to make it larger, toward zero.</li>
<li>Suppose instead that we fed the datapoint <code>[-0.3, 0.5]</code> to the SVM. It computes <code>1 * (-0.3) + (-2) * 0.5 - 1 = -2.3</code>. The label for this point is <code>-1</code>, and since <code>-2.3</code> is smaller than <code>-1</code>, we see that according to our force specification the SVM should be happy: The computed score is very negative, consistent with the negative label of this example. There will be no pull at the end of the circuit (i.e it&rsquo;s zero), since there no changes are necessary. However, there will <em>still</em> be the regularization pull on <code>a</code> of <code>-1</code> and on <code>b</code> of <code>+2</code>.</li>
</ul>
<p>Okay there&rsquo;s been too much text. Lets write the SVM code and take advantage of the circuit machinery we have from Chapter 1:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="c1">// A circuit: it takes 5 Units (x,y,a,b,c) and outputs a single Unit
</span></span></span><span class="line"><span class="cl"><span class="c1">// It can also compute the gradient w.r.t. its inputs
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">Circuit</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// create some gates
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">this</span><span class="p">.</span><span class="nx">mulg0</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">multiplyGate</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">this</span><span class="p">.</span><span class="nx">mulg1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">multiplyGate</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">this</span><span class="p">.</span><span class="nx">addg0</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">addGate</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">this</span><span class="p">.</span><span class="nx">addg1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">addGate</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nx">Circuit</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">forward</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span><span class="nx">y</span><span class="p">,</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">,</span><span class="nx">c</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">ax</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">mulg0</span><span class="p">.</span><span class="nx">forward</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">x</span><span class="p">);</span> <span class="c1">// a*x
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">this</span><span class="p">.</span><span class="nx">by</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">mulg1</span><span class="p">.</span><span class="nx">forward</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="nx">y</span><span class="p">);</span> <span class="c1">// b*y
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">this</span><span class="p">.</span><span class="nx">axpby</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">addg0</span><span class="p">.</span><span class="nx">forward</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">ax</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">by</span><span class="p">);</span> <span class="c1">// a*x + b*y
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">this</span><span class="p">.</span><span class="nx">axpbypc</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">addg1</span><span class="p">.</span><span class="nx">forward</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">axpby</span><span class="p">,</span> <span class="nx">c</span><span class="p">);</span> <span class="c1">// a*x + b*y + c
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">axpbypc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span>
</span></span><span class="line"><span class="cl">  <span class="nx">backward</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">gradient_top</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// takes pull from above
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">this</span><span class="p">.</span><span class="nx">axpbypc</span><span class="p">.</span><span class="nx">grad</span> <span class="o">=</span> <span class="nx">gradient_top</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">addg1</span><span class="p">.</span><span class="nx">backward</span><span class="p">();</span> <span class="c1">// sets gradient in axpby and c
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">this</span><span class="p">.</span><span class="nx">addg0</span><span class="p">.</span><span class="nx">backward</span><span class="p">();</span> <span class="c1">// sets gradient in ax and by
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">this</span><span class="p">.</span><span class="nx">mulg1</span><span class="p">.</span><span class="nx">backward</span><span class="p">();</span> <span class="c1">// sets gradient in b and y
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">this</span><span class="p">.</span><span class="nx">mulg0</span><span class="p">.</span><span class="nx">backward</span><span class="p">();</span> <span class="c1">// sets gradient in a and x
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>That&rsquo;s a circuit that simply computes <code>a*x + b*y + c</code> and can also compute the gradient. It uses the gates code we developed in Chapter 1. Now lets write the SVM, which doesn&rsquo;t care about the actual circuit. It is only concerned with the values that come out of it, and it pulls on the circuit.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="c1">// SVM class
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">SVM</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="c1">// random initial parameter values
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">this</span><span class="p">.</span><span class="nx">a</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Unit</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">  <span class="k">this</span><span class="p">.</span><span class="nx">b</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Unit</span><span class="p">(</span><span class="o">-</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">this</span><span class="p">.</span><span class="nx">c</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Unit</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">this</span><span class="p">.</span><span class="nx">circuit</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Circuit</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nx">SVM</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">forward</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// assume x and y are Units
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">this</span><span class="p">.</span><span class="nx">unit_out</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">circuit</span><span class="p">.</span><span class="nx">forward</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">a</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">b</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">c</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">unit_out</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span>
</span></span><span class="line"><span class="cl">  <span class="nx">backward</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">label</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// label is +1 or -1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// reset pulls on a,b,c
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">this</span><span class="p">.</span><span class="nx">a</span><span class="p">.</span><span class="nx">grad</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">b</span><span class="p">.</span><span class="nx">grad</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">c</span><span class="p">.</span><span class="nx">grad</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// compute the pull based on what the circuit output was
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">var</span> <span class="nx">pull</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="nx">label</span> <span class="o">===</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="p">.</span><span class="nx">unit_out</span><span class="p">.</span><span class="nx">value</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">      <span class="nx">pull</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// the score was too low: pull up
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="nx">label</span> <span class="o">===</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="p">.</span><span class="nx">unit_out</span><span class="p">.</span><span class="nx">value</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">pull</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// the score was too high for a positive example, pull down
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">circuit</span><span class="p">.</span><span class="nx">backward</span><span class="p">(</span><span class="nx">pull</span><span class="p">);</span> <span class="c1">// writes gradient into x,y,a,b,c
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="c1">// add regularization pull for parameters: towards zero and proportional to value
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">this</span><span class="p">.</span><span class="nx">a</span><span class="p">.</span><span class="nx">grad</span> <span class="o">+=</span> <span class="o">-</span><span class="k">this</span><span class="p">.</span><span class="nx">a</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">b</span><span class="p">.</span><span class="nx">grad</span> <span class="o">+=</span> <span class="o">-</span><span class="k">this</span><span class="p">.</span><span class="nx">b</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span>
</span></span><span class="line"><span class="cl">  <span class="nx">learnFrom</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">label</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">forward</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">);</span> <span class="c1">// forward pass (set .value in all Units)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">this</span><span class="p">.</span><span class="nx">backward</span><span class="p">(</span><span class="nx">label</span><span class="p">);</span> <span class="c1">// backward pass (set .grad in all Units)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">this</span><span class="p">.</span><span class="nx">parameterUpdate</span><span class="p">();</span> <span class="c1">// parameters respond to tug
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">},</span>
</span></span><span class="line"><span class="cl">  <span class="nx">parameterUpdate</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">step_size</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">a</span><span class="p">.</span><span class="nx">value</span> <span class="o">+=</span> <span class="nx">step_size</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">a</span><span class="p">.</span><span class="nx">grad</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">b</span><span class="p">.</span><span class="nx">value</span> <span class="o">+=</span> <span class="nx">step_size</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">b</span><span class="p">.</span><span class="nx">grad</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">c</span><span class="p">.</span><span class="nx">value</span> <span class="o">+=</span> <span class="nx">step_size</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">c</span><span class="p">.</span><span class="nx">grad</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Now lets train the SVM with Stochastic Gradient Descent:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">data</span> <span class="o">=</span> <span class="p">[];</span> <span class="kd">var</span> <span class="nx">labels</span> <span class="o">=</span> <span class="p">[];</span>
</span></span><span class="line"><span class="cl"><span class="nx">data</span><span class="p">.</span><span class="nx">push</span><span class="p">([</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">]);</span> <span class="nx">labels</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">data</span><span class="p">.</span><span class="nx">push</span><span class="p">([</span><span class="o">-</span><span class="mf">0.3</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">]);</span> <span class="nx">labels</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">data</span><span class="p">.</span><span class="nx">push</span><span class="p">([</span><span class="mf">3.0</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">]);</span> <span class="nx">labels</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">data</span><span class="p">.</span><span class="nx">push</span><span class="p">([</span><span class="o">-</span><span class="mf">0.1</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">]);</span> <span class="nx">labels</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">data</span><span class="p">.</span><span class="nx">push</span><span class="p">([</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.1</span><span class="p">]);</span> <span class="nx">labels</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">data</span><span class="p">.</span><span class="nx">push</span><span class="p">([</span><span class="mf">2.1</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">]);</span> <span class="nx">labels</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">svm</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">SVM</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// a function that computes the classification accuracy
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">evalTrainingAccuracy</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">var</span> <span class="nx">num_correct</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">data</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Unit</span><span class="p">(</span><span class="nx">data</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="mf">0.0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">y</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Unit</span><span class="p">(</span><span class="nx">data</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="mf">0.0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">true_label</span> <span class="o">=</span> <span class="nx">labels</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// see if the prediction matches the provided label
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">var</span> <span class="nx">predicted_label</span> <span class="o">=</span> <span class="nx">svm</span><span class="p">.</span><span class="nx">forward</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">).</span><span class="nx">value</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="nx">predicted_label</span> <span class="o">===</span> <span class="nx">true_label</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">num_correct</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">num_correct</span> <span class="o">/</span> <span class="nx">data</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// the learning loop
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">iter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">iter</span> <span class="o">&lt;</span> <span class="mi">400</span><span class="p">;</span> <span class="nx">iter</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// pick a random data point
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">()</span> <span class="o">*</span> <span class="nx">data</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Unit</span><span class="p">(</span><span class="nx">data</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="mf">0.0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kd">var</span> <span class="nx">y</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Unit</span><span class="p">(</span><span class="nx">data</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="mf">0.0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kd">var</span> <span class="nx">label</span> <span class="o">=</span> <span class="nx">labels</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="nx">svm</span><span class="p">.</span><span class="nx">learnFrom</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">label</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span><span class="nx">iter</span> <span class="o">%</span> <span class="mi">25</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// every 10 iterations... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;training accuracy at iter &#39;</span> <span class="o">+</span> <span class="nx">iter</span> <span class="o">+</span> <span class="s1">&#39;: &#39;</span> <span class="o">+</span> <span class="nx">evalTrainingAccuracy</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>This code prints the following output:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">training accuracy at iteration 0: 0.3333333333333333
</span></span><span class="line"><span class="cl">training accuracy at iteration 25: 0.3333333333333333
</span></span><span class="line"><span class="cl">training accuracy at iteration 50: 0.5
</span></span><span class="line"><span class="cl">training accuracy at iteration 75: 0.5
</span></span><span class="line"><span class="cl">training accuracy at iteration 100: 0.3333333333333333
</span></span><span class="line"><span class="cl">training accuracy at iteration 125: 0.5
</span></span><span class="line"><span class="cl">training accuracy at iteration 150: 0.5
</span></span><span class="line"><span class="cl">training accuracy at iteration 175: 0.5
</span></span><span class="line"><span class="cl">training accuracy at iteration 200: 0.5
</span></span><span class="line"><span class="cl">training accuracy at iteration 225: 0.6666666666666666
</span></span><span class="line"><span class="cl">training accuracy at iteration 250: 0.6666666666666666
</span></span><span class="line"><span class="cl">training accuracy at iteration 275: 0.8333333333333334
</span></span><span class="line"><span class="cl">training accuracy at iteration 300: 1
</span></span><span class="line"><span class="cl">training accuracy at iteration 325: 1
</span></span><span class="line"><span class="cl">training accuracy at iteration 350: 1
</span></span><span class="line"><span class="cl">training accuracy at iteration 375: 1 
</span></span></code></pre></td></tr></table>
</div>
</div><p>We see that initially our classifier only had 33% training accuracy, but by the end all training examples are correctly classifier as the parameters <code>a,b,c</code> adjusted their values according to the pulls we exerted. We just trained an SVM! But please don&rsquo;t use this code anywhere in production :) We will see how we can make things much more efficient once we understand what is going on at the core.</p>
<p><strong>Number of iterations needed</strong>. With this example data, with this example initialization, and with the setting of step size we used, it took about 300 iterations to train the SVM. In practice, this could be many more or many less depending on how hard or large the problem is, how you&rsquo;re initializating, normalizing your data, what step size you&rsquo;re using, and so on. This is just a toy demonstration, but later we will go over all the best practices for actually training these classifiers in practice. For example, it will turn out that the setting of the step size is very imporant and tricky. Small step size will make your model slow to train. Large step size will train faster, but if it is too large, it will make your classifier chaotically jump around and not converge to a good final result. We will eventually use witheld validation data to properly tune it to be just in the sweet spot for your particular data.</p>
<p>One thing I&rsquo;d like you to appreciate is that the circuit can be arbitrary expression, not just the linear prediction function we used in this example. For example, it can be an entire neural network.</p>
<p>By the way, I intentionally structured the code in a modular way, but we could have trained an SVM with a much simpler code. Here is really what all of these classes and computations boil down to:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">b</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="nx">c</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// initial parameters
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">iter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">iter</span> <span class="o">&lt;</span> <span class="mi">400</span><span class="p">;</span> <span class="nx">iter</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// pick a random data point
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">()</span> <span class="o">*</span> <span class="nx">data</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">data</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="kd">var</span> <span class="nx">y</span> <span class="o">=</span> <span class="nx">data</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="kd">var</span> <span class="nx">label</span> <span class="o">=</span> <span class="nx">labels</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// compute pull
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kd">var</span> <span class="nx">score</span> <span class="o">=</span> <span class="nx">a</span><span class="o">*</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">b</span><span class="o">*</span><span class="nx">y</span> <span class="o">+</span> <span class="nx">c</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kd">var</span> <span class="nx">pull</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span><span class="nx">label</span> <span class="o">===</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="nx">score</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="nx">pull</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span><span class="nx">label</span> <span class="o">===</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="nx">score</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="nx">pull</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// compute gradient and update parameters
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kd">var</span> <span class="nx">step_size</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">a</span> <span class="o">+=</span> <span class="nx">step_size</span> <span class="o">*</span> <span class="p">(</span><span class="nx">x</span> <span class="o">*</span> <span class="nx">pull</span> <span class="o">-</span> <span class="nx">a</span><span class="p">);</span> <span class="c1">// -a is from the regularization
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">b</span> <span class="o">+=</span> <span class="nx">step_size</span> <span class="o">*</span> <span class="p">(</span><span class="nx">y</span> <span class="o">*</span> <span class="nx">pull</span> <span class="o">-</span> <span class="nx">b</span><span class="p">);</span> <span class="c1">// -b is from the regularization
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">c</span> <span class="o">+=</span> <span class="nx">step_size</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">pull</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>this code gives an identical result. Perhaps by now you can glance at the code and see how these equations came about.</p>
<p><strong>Variable pull?</strong> A quick note to make at this point: You may have noticed that the pull is always 1,0, or -1. You could imagine doing other things, for example making this pull proportional to how bad the mistake was. This leads to a variation on the SVM that some people refer to as <em>squared hinge loss</em> SVM, for reasons that will later become clear. Depending on various features of your dataset, that may work better or worse. For example, if you have very bad outliers in your data, e.g. a negative data point that gets a score <code>+100</code>, its influence will be relatively minor on our classifier because we will only pull with force of <code>-1</code> regardless of how bad the mistake was. In practice we refer to this property of a classifier as <strong>robustness</strong> to outliers.</p>
<p>Lets <strong>recap</strong>. We introduced the <strong>binary classification</strong> problem, where we are given N D-dimensional vectors and a label +1/-1 for each. We saw that we can combine these features with a set of parameters inside a real-valued circuit (such as a <strong>Support Vector Machine</strong> circuit in our example). Then, we can repeatedly pass our data through the circuit and each time tweak the parameters so that the circuit&rsquo;s output value is consistent with the provided labels. The tweaking relied, crucially, on our ability to <strong>backpropagate</strong> gradients through the circuit. In the end, the final circuit can be used to predict values for unseen instances!</p>
<h4 id="generalizing-the-svm-into-a-neural-network">Generalizing the SVM into a Neural Network</h4>
<p>Of interest is the fact that an SVM is just a particular type of a very simple circuit (circuit that computes <code>score = a*x + b*y + c</code> where <code>a,b,c</code> are weights and <code>x,y</code> are data points). This can be easily extended to more complicated functions. For example, lets write a 2-layer Neural Network that does the binary classification. The forward pass will look like this:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="c1">// assume inputs x,y
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">n1</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">a1</span><span class="o">*</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">b1</span><span class="o">*</span><span class="nx">y</span> <span class="o">+</span> <span class="nx">c1</span><span class="p">);</span> <span class="c1">// activation of 1st hidden neuron
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">n2</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">a2</span><span class="o">*</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">b2</span><span class="o">*</span><span class="nx">y</span> <span class="o">+</span> <span class="nx">c2</span><span class="p">);</span> <span class="c1">// 2nd neuron
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">n3</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">a3</span><span class="o">*</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">b3</span><span class="o">*</span><span class="nx">y</span> <span class="o">+</span> <span class="nx">c3</span><span class="p">);</span> <span class="c1">// 3rd neuron
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">score</span> <span class="o">=</span> <span class="nx">a4</span><span class="o">*</span><span class="nx">n1</span> <span class="o">+</span> <span class="nx">b4</span><span class="o">*</span><span class="nx">n2</span> <span class="o">+</span> <span class="nx">c4</span><span class="o">*</span><span class="nx">n3</span> <span class="o">+</span> <span class="nx">d4</span><span class="p">;</span> <span class="c1">// the score
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>The specification above is a 2-layer Neural Network with 3 hidden neurons (n1, n2, n3) that uses Rectified Linear Unit (ReLU) non-linearity on each hidden neuron. As you can see, there are now several parameters involved, which means that our classifier is more complex and can represent more intricate decision boundaries than just a simple linear decision rule such as an SVM. Another way to think about it is that every one of the three hidden neurons is a linear classifier and now we&rsquo;re putting an extra linear classifier on top of that. Now we&rsquo;re starting to go <em>deeper</em> :). Okay, lets train this 2-layer Neural Network. The code looks very similar to the SVM example code above, we just have to change the forward pass and the backward pass:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="c1">// random initial parameters
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">a1</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">()</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">;</span> <span class="c1">// a random number between -0.5 and 0.5
</span></span></span><span class="line"><span class="cl"><span class="c1">// ... similarly initialize all other parameters to randoms
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">iter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">iter</span> <span class="o">&lt;</span> <span class="mi">400</span><span class="p">;</span> <span class="nx">iter</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// pick a random data point
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">()</span> <span class="o">*</span> <span class="nx">data</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">data</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="kd">var</span> <span class="nx">y</span> <span class="o">=</span> <span class="nx">data</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="kd">var</span> <span class="nx">label</span> <span class="o">=</span> <span class="nx">labels</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// compute forward pass
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kd">var</span> <span class="nx">n1</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">a1</span><span class="o">*</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">b1</span><span class="o">*</span><span class="nx">y</span> <span class="o">+</span> <span class="nx">c1</span><span class="p">);</span> <span class="c1">// activation of 1st hidden neuron
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kd">var</span> <span class="nx">n2</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">a2</span><span class="o">*</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">b2</span><span class="o">*</span><span class="nx">y</span> <span class="o">+</span> <span class="nx">c2</span><span class="p">);</span> <span class="c1">// 2nd neuron
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kd">var</span> <span class="nx">n3</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">a3</span><span class="o">*</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">b3</span><span class="o">*</span><span class="nx">y</span> <span class="o">+</span> <span class="nx">c3</span><span class="p">);</span> <span class="c1">// 3rd neuron
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kd">var</span> <span class="nx">score</span> <span class="o">=</span> <span class="nx">a4</span><span class="o">*</span><span class="nx">n1</span> <span class="o">+</span> <span class="nx">b4</span><span class="o">*</span><span class="nx">n2</span> <span class="o">+</span> <span class="nx">c4</span><span class="o">*</span><span class="nx">n3</span> <span class="o">+</span> <span class="nx">d4</span><span class="p">;</span> <span class="c1">// the score
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="c1">// compute the pull on top
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kd">var</span> <span class="nx">pull</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span><span class="nx">label</span> <span class="o">===</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="nx">score</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="nx">pull</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// we want higher output! Pull up.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span><span class="p">(</span><span class="nx">label</span> <span class="o">===</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="nx">score</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="nx">pull</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// we want lower output! Pull down.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="c1">// now compute backward pass to all parameters of the model
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="c1">// backprop through the last &#34;score&#34; neuron
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kd">var</span> <span class="nx">dscore</span> <span class="o">=</span> <span class="nx">pull</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kd">var</span> <span class="nx">da4</span> <span class="o">=</span> <span class="nx">n1</span> <span class="o">*</span> <span class="nx">dscore</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kd">var</span> <span class="nx">dn1</span> <span class="o">=</span> <span class="nx">a4</span> <span class="o">*</span> <span class="nx">dscore</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kd">var</span> <span class="nx">db4</span> <span class="o">=</span> <span class="nx">n2</span> <span class="o">*</span> <span class="nx">dscore</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kd">var</span> <span class="nx">dn2</span> <span class="o">=</span> <span class="nx">b4</span> <span class="o">*</span> <span class="nx">dscore</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kd">var</span> <span class="nx">dc4</span> <span class="o">=</span> <span class="nx">n3</span> <span class="o">*</span> <span class="nx">dscore</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kd">var</span> <span class="nx">dn3</span> <span class="o">=</span> <span class="nx">c4</span> <span class="o">*</span> <span class="nx">dscore</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kd">var</span> <span class="nx">dd4</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="nx">dscore</span><span class="p">;</span> <span class="c1">// phew
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="c1">// backprop the ReLU non-linearities, in place
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// i.e. just set gradients to zero if the neurons did not &#34;fire&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kd">var</span> <span class="nx">dn3</span> <span class="o">=</span> <span class="nx">n3</span> <span class="o">===</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="nx">dn3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kd">var</span> <span class="nx">dn2</span> <span class="o">=</span> <span class="nx">n2</span> <span class="o">===</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="nx">dn2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kd">var</span> <span class="nx">dn1</span> <span class="o">=</span> <span class="nx">n1</span> <span class="o">===</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="nx">dn1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// backprop to parameters of neuron 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kd">var</span> <span class="nx">da1</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">dn1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kd">var</span> <span class="nx">db1</span> <span class="o">=</span> <span class="nx">y</span> <span class="o">*</span> <span class="nx">dn1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kd">var</span> <span class="nx">dc1</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="nx">dn1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="c1">// backprop to parameters of neuron 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kd">var</span> <span class="nx">da2</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">dn2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kd">var</span> <span class="nx">db2</span> <span class="o">=</span> <span class="nx">y</span> <span class="o">*</span> <span class="nx">dn2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kd">var</span> <span class="nx">dc2</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="nx">dn2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// backprop to parameters of neuron 3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kd">var</span> <span class="nx">da3</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">dn3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kd">var</span> <span class="nx">db3</span> <span class="o">=</span> <span class="nx">y</span> <span class="o">*</span> <span class="nx">dn3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kd">var</span> <span class="nx">dc3</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="nx">dn3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// phew! End of backprop!
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// note we could have also backpropped into x,y
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// but we do not need these gradients. We only use the gradients
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// on our parameters in the parameter update, and we discard x,y
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="c1">// add the pulls from the regularization, tugging all multiplicative
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// parameters (i.e. not the biases) downward, proportional to their value
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">da1</span> <span class="o">+=</span> <span class="o">-</span><span class="nx">a1</span><span class="p">;</span> <span class="nx">da2</span> <span class="o">+=</span> <span class="o">-</span><span class="nx">a2</span><span class="p">;</span> <span class="nx">da3</span> <span class="o">+=</span> <span class="o">-</span><span class="nx">a3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">db1</span> <span class="o">+=</span> <span class="o">-</span><span class="nx">b1</span><span class="p">;</span> <span class="nx">db2</span> <span class="o">+=</span> <span class="o">-</span><span class="nx">b2</span><span class="p">;</span> <span class="nx">db3</span> <span class="o">+=</span> <span class="o">-</span><span class="nx">b3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">da4</span> <span class="o">+=</span> <span class="o">-</span><span class="nx">a4</span><span class="p">;</span> <span class="nx">db4</span> <span class="o">+=</span> <span class="o">-</span><span class="nx">b4</span><span class="p">;</span> <span class="nx">dc4</span> <span class="o">+=</span> <span class="o">-</span><span class="nx">c4</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// finally, do the parameter update
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kd">var</span> <span class="nx">step_size</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">a1</span> <span class="o">+=</span> <span class="nx">step_size</span> <span class="o">*</span> <span class="nx">da1</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">  <span class="nx">b1</span> <span class="o">+=</span> <span class="nx">step_size</span> <span class="o">*</span> <span class="nx">db1</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">  <span class="nx">c1</span> <span class="o">+=</span> <span class="nx">step_size</span> <span class="o">*</span> <span class="nx">dc1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">a2</span> <span class="o">+=</span> <span class="nx">step_size</span> <span class="o">*</span> <span class="nx">da2</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">  <span class="nx">b2</span> <span class="o">+=</span> <span class="nx">step_size</span> <span class="o">*</span> <span class="nx">db2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">c2</span> <span class="o">+=</span> <span class="nx">step_size</span> <span class="o">*</span> <span class="nx">dc2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">a3</span> <span class="o">+=</span> <span class="nx">step_size</span> <span class="o">*</span> <span class="nx">da3</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">  <span class="nx">b3</span> <span class="o">+=</span> <span class="nx">step_size</span> <span class="o">*</span> <span class="nx">db3</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">  <span class="nx">c3</span> <span class="o">+=</span> <span class="nx">step_size</span> <span class="o">*</span> <span class="nx">dc3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">a4</span> <span class="o">+=</span> <span class="nx">step_size</span> <span class="o">*</span> <span class="nx">da4</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">  <span class="nx">b4</span> <span class="o">+=</span> <span class="nx">step_size</span> <span class="o">*</span> <span class="nx">db4</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">  <span class="nx">c4</span> <span class="o">+=</span> <span class="nx">step_size</span> <span class="o">*</span> <span class="nx">dc4</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">  <span class="nx">d4</span> <span class="o">+=</span> <span class="nx">step_size</span> <span class="o">*</span> <span class="nx">dd4</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// wow this is tedious, please use for loops in prod.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// we&#39;re done!
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>And that&rsquo;s how you train a neural network. Obviously, you want to modularize your code nicely but I expended this example for you in the hope that it makes things much more concrete and simpler to understand. Later, we will look at best practices when implementing these networks and we will structure the code much more neatly in a modular and more sensible way.</p>
<p>But for now, I hope your takeaway is that a 2-layer Neural Net is really not such a scary thing: we write a forward pass expression, interpret the value at the end as a score, and then we pull on that value in a positive or negative direction depending on what we want that value to be for our current particular example. The parameter update after backprop will ensure that when we see this particular example in the future, the network will be more likely to give us a value we desire, not the one it gave just before the update.</p>
<h3 id="a-more-conventional-approach-loss-functions">A more Conventional Approach: Loss Functions</h3>
<p>Now that we understand the basics of how these circuits function with data, lets adopt a more conventional approach that you might see elsewhere on the internet and in other tutorials and books. You won&rsquo;t see people talking too much about <strong>force specifications</strong>. Instead, Machine Learning algorithms are specified in terms of <strong>loss functions</strong> (or <strong>cost functions</strong>, or <strong>objectives</strong>).</p>
<p>As I develop this formalism I would also like to start to be a little more careful with how we name our variables and parameters. I&rsquo;d like these equations to look similar to what you might see in a book or some other tutorial, so let me use more standard naming conventions.</p>
<h4 id="example-2-d-support-vector-machine">Example: 2-D Support Vector Machine</h4>
<p>Lets start with an example of a 2-dimensional SVM. We are given a dataset of \( N \) examples \( (x_{i0}, x_{i1}) \) and their corresponding labels \( y_{i} \) which are allowed to be either \( +1/-1 \) for positive or negative example respectively. Most importantly, as you recall we have three parameters \( (w_0, w_1, w_2) \). The SVM loss function is then defined as follows:</p>
<p>$$
L = [\sum_{i=1}^N max(0, -y_{i}( w_0x_{i0} + w_1x_{i1} + w_2 ) + 1 )] + \alpha [w_0^2 + w_1^2]
$$</p>
<p>Notice that this expression is always positive, due to the thresholding at zero in the first expression and the squaring in the regularization. The idea is that we will want this expression to be as small as possible. Before we dive into some of its subtleties let me first translate it to code:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">X</span> <span class="o">=</span> <span class="p">[</span> <span class="p">[</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">]</span> <span class="p">]</span> <span class="c1">// array of 2-dimensional data
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">y</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="c1">// array of labels
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">w</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">]</span> <span class="c1">// example: random numbers
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">alpha</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">;</span> <span class="c1">// regularization strength
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">cost</span><span class="p">(</span><span class="nx">X</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="kd">var</span> <span class="nx">total_cost</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span> <span class="c1">// L, in SVM loss function above
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">N</span> <span class="o">=</span> <span class="nx">X</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="o">&lt;</span><span class="nx">N</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// loop over all data points and compute their score
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">var</span> <span class="nx">xi</span> <span class="o">=</span> <span class="nx">X</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">score</span> <span class="o">=</span> <span class="nx">w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nx">xi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="nx">w</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="nx">xi</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="nx">w</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// accumulate cost based on how compatible the score is with the label
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">var</span> <span class="nx">yi</span> <span class="o">=</span> <span class="nx">y</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span> <span class="c1">// label
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">var</span> <span class="nx">costi</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span> <span class="nx">yi</span> <span class="o">*</span> <span class="nx">score</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;example &#39;</span> <span class="o">+</span> <span class="nx">i</span> <span class="o">+</span> <span class="s1">&#39;: xi = (&#39;</span> <span class="o">+</span> <span class="nx">xi</span> <span class="o">+</span> <span class="s1">&#39;) and label = &#39;</span> <span class="o">+</span> <span class="nx">yi</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;  score computed to be &#39;</span> <span class="o">+</span> <span class="nx">score</span><span class="p">.</span><span class="nx">toFixed</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;  =&gt; cost computed to be &#39;</span> <span class="o">+</span> <span class="nx">costi</span><span class="p">.</span><span class="nx">toFixed</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="nx">total_cost</span> <span class="o">+=</span> <span class="nx">costi</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// regularization cost: we want small weights
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">reg_cost</span> <span class="o">=</span> <span class="nx">alpha</span> <span class="o">*</span> <span class="p">(</span><span class="nx">w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="nx">w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="nx">w</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="nx">w</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;regularization cost for current model is &#39;</span> <span class="o">+</span> <span class="nx">reg_cost</span><span class="p">.</span><span class="nx">toFixed</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="nx">total_cost</span> <span class="o">+=</span> <span class="nx">reg_cost</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;total cost is &#39;</span> <span class="o">+</span> <span class="nx">total_cost</span><span class="p">.</span><span class="nx">toFixed</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">total_cost</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>And here is the output:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">cost for example 0 is 0.440
</span></span><span class="line"><span class="cl">cost for example 1 is 1.370
</span></span><span class="line"><span class="cl">cost for example 2 is 0.000
</span></span><span class="line"><span class="cl">regularization cost for current model is 0.005
</span></span><span class="line"><span class="cl">total cost is 1.815 
</span></span></code></pre></td></tr></table>
</div>
</div><p>Notice how this expression works: It measures how <em>bad</em> our SVM classifier is. Lets step through this explicitly:</p>
<ul>
<li>The first datapoint <code>xi = [1.2, 0.7]</code> with label <code>yi = 1</code> will give score <code>0.1*1.2 + 0.2*0.7 + 0.3</code>, which is <code>0.56</code>. Notice, this is a positive example so we want to the score to be greater than <code>+1</code>. <code>0.56</code> is not enough. And indeed, the expression for cost for this datapoint will compute: <code>costi = Math.max(0, -1*0.56 + 1)</code>, which is <code>0.44</code>. You can think of the cost as quantifying the SVM&rsquo;s unhappiness.</li>
<li>The second datapoint <code>xi = [-0.3, 0.5]</code> with label <code>yi = -1</code> will give score <code>0.1*(-0.3) + 0.2*0.5 + 0.3</code>, which is <code>0.37</code>. This isn&rsquo;t looking very good: This score is very high for a negative example. It should be less than -1. Indeed, when we compute the cost: <code>costi = Math.max(0, 1*0.37 + 1)</code>, we get <code>1.37</code>. That&rsquo;s a very high cost from this example, as it is being misclassified.</li>
<li>The last example <code>xi = [3, 2.5]</code> with label <code>yi = 1</code> gives score <code>0.1*3 + 0.2*2.5 + 0.3</code>, and that is <code>1.1</code>. In this case, the SVM will compute <code>costi = Math.max(0, -1*1.1 + 1)</code>, which is in fact zero. This datapoint is being classified correctly and there is no cost associated with it.</li>
</ul>
<blockquote>
<p>A cost function is an expression that measuress how bad your classifier is. When the training set is perfectly classified, the cost (ignoring the regularization) will be zero.</p>
</blockquote>
<p>Notice that the last term in the loss is the regularization cost, which says that our model parameters should be small values. Due to this term the cost will never actually become zero (because this would mean all parameters of the model except the bias are exactly zero), but the closer we get, the better our classifier will become.</p>
<blockquote>
<p>The majority of cost functions in Machine Learning consist of two parts: 1. A part that measures how well a model fits the data, and 2: Regularization, which measures some notion of how complex or likely a model is.</p>
</blockquote>
<p>I hope I convinced you then, that to get a very good SVM we really want to make the <strong>cost as small as possible</strong>. Sounds familiar? We know exactly what to do: The cost function written above is our circuit. We will forward all examples through the circuit, compute the backward pass and update all parameters such that the circuit will output a <em>smaller</em> cost in the future. Specifically, we will compute the <em>gradient</em> and then update the parameters in the <em>opposite direction</em> of the gradient (since we want to make the cost small, not large).</p>
<blockquote>
<p>&ldquo;We know exactly what to do: The cost function written above is our circuit.&rdquo;</p>
</blockquote>
<p>todo: clean up this section and flesh it out a bit&hellip;</p>
<h2 id="chapter-3-backprop-in-practice">Chapter 3: Backprop in Practice</h2>
<h3 id="building-up-a-library">Building up a library</h3>
<h3 id="example-practical-neural-network-classifier">Example: Practical Neural Network Classifier</h3>
<ul>
<li>Multiclass: Structured SVM</li>
<li>Multiclass: Logistic Regression, Softmax</li>
</ul>
<h3 id="example-regression">Example: Regression</h3>
<p>Tiny changes needed to cost function. L2 regularization.</p>
<h3 id="example-structured-prediction">Example: Structured Prediction</h3>
<p>Basic idea is to train an (unnormalized) energy model</p>
<h3 id="vectorized-implementations">Vectorized Implementations</h3>
<p>Writing a Neural Net classfier in Python with numpy&hellip;.</p>
<h3 id="backprop-in-practice-tipstricks">Backprop in practice: Tips/Tricks</h3>
<ul>
<li>Monitoring of Cost function</li>
<li>Monitoring training/validation performance</li>
<li>Tweaking initial learning rates, learning rate schedules</li>
<li>Optimization: Using Momentum</li>
<li>Optimization: LBFGS, Nesterov accelerated gradient</li>
<li>Importance of Initialization: weights and biases</li>
<li>Regularization: L2, L1, Group sparsity, Dropout</li>
<li>Hyperparameter search, cross-validations</li>
<li>Common pitfalls: (e.g. dying ReLUs)</li>
<li>Handling unbalanced datasets</li>
<li>Approaches to debugging nets when something doesnt work</li>
</ul>
<h2 id="chapter-4-networks-in-the-wild">Chapter 4: Networks in the Wild</h2>
<p>Case studies of models that work well in practice and have been deployed in the wild.</p>
<h3 id="case-study-convolutional-neural-networks-for-images">Case Study: Convolutional Neural Networks for images</h3>
<p>Convolutional layers, pooling, AlexNet, etc.</p>
<h3 id="case-study-recurrent-neural-networks-for-speech-and-text">Case Study: Recurrent Neural Networks for Speech and Text</h3>
<p>Vanilla Recurrent nets, bi-directional recurrent nets. Maybe overview of LSTM</p>
<h3 id="case-study-word2vec">Case Study: Word2Vec</h3>
<p>Training word vector representations in NLP</p>
<h3 id="case-study-t-sne">Case Study: t-SNE</h3>
<p>Training embeddings for visualizing data</p>
<h2 id="acknowledgements">Acknowledgements</h2>
<p>Thanks a lot to the following people who made this guide better: wodenokoto (HN), zackmorris (HN).</p>
<h2 id="comments">Comments</h2>
<p>This guide is a work in progress and I appreciate feedback, especially regarding parts that were unclear or only made half sense. Thank you!</p>
<p>Some of the Javascript code in this tutorial has been translated to Python by Ajit, find it over on <a href="https://github.com/urwithajit9/HG_NeuralNetwork" target="_blank" rel="noopener noreffer">Github</a>.</p>
</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>Updated on 0001-01-01</span>
            </div>
            <div class="post-info-license"></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"><span>
                            <a class="link-to-markdown" href="/nntutorial/index.md" target="_blank">Read Markdown</a>
                        </span></div>
            <div class="post-info-share">
                <span><a href="javascript:void(0);" title="Share on Twitter" data-sharer="twitter" data-url="http://example.org/nntutorial/" data-title="Hacker&#39;s guide to Neural Networks"><i class="fab fa-twitter fa-fw"></i></a><a href="javascript:void(0);" title="Share on Facebook" data-sharer="facebook" data-url="http://example.org/nntutorial/"><i class="fab fa-facebook-square fa-fw"></i></a><a href="javascript:void(0);" title="Share on WhatsApp" data-sharer="whatsapp" data-url="http://example.org/nntutorial/" data-title="Hacker&#39;s guide to Neural Networks" data-web><i class="fab fa-whatsapp fa-fw"></i></a><a href="javascript:void(0);" title="Share on Line" data-sharer="line" data-url="http://example.org/nntutorial/" data-title="Hacker&#39;s guide to Neural Networks"><i data-svg-src="/lib/simple-icons/icons/line.min.svg"></i></a><a href="javascript:void(0);" title="Share on 微博" data-sharer="weibo" data-url="http://example.org/nntutorial/" data-title="Hacker&#39;s guide to Neural Networks"><i class="fab fa-weibo fa-fw"></i></a><a href="javascript:void(0);" title="Share on Myspace" data-sharer="myspace" data-url="http://example.org/nntutorial/" data-title="Hacker&#39;s guide to Neural Networks" data-description=""><i data-svg-src="/lib/simple-icons/icons/myspace.min.svg"></i></a><a href="javascript:void(0);" title="Share on Blogger" data-sharer="blogger" data-url="http://example.org/nntutorial/" data-title="Hacker&#39;s guide to Neural Networks" data-description=""><i class="fab fa-blogger fa-fw"></i></a><a href="javascript:void(0);" title="Share on Evernote" data-sharer="evernote" data-url="http://example.org/nntutorial/" data-title="Hacker&#39;s guide to Neural Networks"><i class="fab fa-evernote fa-fw"></i></a></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">Back</a></span>&nbsp;|&nbsp;<span><a href="/">Home</a></span>
        </section>
    </div>

    <div class="post-nav">
            <a href="/test_post/" class="next" rel="next" title="Test_post">Test_post<i class="fas fa-angle-right fa-fw"></i></a></div>
</div>
<div id="comments"></div></article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line"><span class="author" itemprop="copyrightHolder">&nbsp;<a href="/" target="_blank">Li Minghui</a></span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="Back to Top">
                <i class="fas fa-arrow-up fa-fw"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="View Comments">
                <i class="fas fa-comment fa-fw"></i>
            </a>
        </div><link rel="stylesheet" href="/lib/katex/katex.min.css"><link rel="stylesheet" href="/lib/katex/copy-tex.min.css"><script type="text/javascript" src="/lib/smooth-scroll/smooth-scroll.min.js"></script><script type="text/javascript" src="/lib/autocomplete/autocomplete.min.js"></script><script type="text/javascript" src="/lib/lunr/lunr.min.js"></script><script type="text/javascript" src="/lib/lazysizes/lazysizes.min.js"></script><script type="text/javascript" src="/lib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="/lib/sharer/sharer.min.js"></script><script type="text/javascript" src="/lib/katex/katex.min.js"></script><script type="text/javascript" src="/lib/katex/auto-render.min.js"></script><script type="text/javascript" src="/lib/katex/copy-tex.min.js"></script><script type="text/javascript" src="/lib/katex/mhchem.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"Copy to clipboard","maxShownLines":10},"comment":{},"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false},"search":{"highlightTag":"em","lunrIndexURL":"/index.json","maxResultLength":10,"noResultsFound":"No results found","snippetLength":30,"type":"lunr"}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
